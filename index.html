<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pok√©mon Type Tool</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; min-height: 100vh; }
  .app { max-width: 480px; margin: 0 auto; padding: 0 0 80px; }
  h1 { text-align: center; padding: 16px 16px 8px; font-size: 1.2rem; color: #a0a0c0; letter-spacing: 1px; }
  .lang-toggle { display: flex; justify-content: center; gap: 0; margin-bottom: 8px; }
  .lang-btn { padding: 4px 14px; border: 1px solid #3a3a6e; background: none; color: #666; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition: all 0.15s; }
  .lang-btn:first-child { border-radius: 6px 0 0 6px; }
  .lang-btn:last-child { border-radius: 0 6px 6px 0; }
  .lang-btn.active { background: #4040cc; color: #fff; border-color: #4040cc; }

  /* Tabs */
  .tabs { display: flex; border-bottom: 2px solid #2a2a4e; }
  .tab { flex: 1; padding: 12px; text-align: center; cursor: pointer; font-size: 0.9rem; color: #888; transition: all 0.2s; }
  .tab.active { color: #fff; border-bottom: 2px solid #6060ff; margin-bottom: -2px; }

  /* Team Grid */
  .team-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 12px; }
  .slot { background: #16213e; border-radius: 12px; padding: 12px; min-height: 80px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s; position: relative; display: flex; flex-direction: column; gap: 6px; }
  .slot:hover { border-color: #3a3a6e; }
  .slot.active { border-color: #6060ff; }
  .slot.empty { align-items: center; justify-content: center; }
  .slot-add { font-size: 2rem; color: #444; }
  .slot-name { font-size: 0.85rem; font-weight: 600; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .slot-types { display: flex; gap: 4px; flex-wrap: wrap; }
  .slot-clear { position: absolute; top: 6px; right: 6px; background: none; border: none; color: #666; font-size: 1rem; cursor: pointer; padding: 2px 6px; border-radius: 4px; }
  .slot-clear:hover { color: #f00; background: #2a1a1a; }

  /* Type badges */
  .badge { display: inline-block; padding: 2px 8px; border-radius: 6px; font-size: 0.7rem; font-weight: 700; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }

  /* Type colors */
  .t-Normal   { background: #A8A878; }
  .t-Fire     { background: #F08030; }
  .t-Water    { background: #6890F0; }
  .t-Electric { background: #F8D030; color: #333; text-shadow: none; }
  .t-Grass    { background: #78C850; }
  .t-Ice      { background: #98D8D8; color: #333; text-shadow: none; }
  .t-Fighting { background: #C03028; }
  .t-Poison   { background: #A040A0; }
  .t-Ground   { background: #E0C068; color: #333; text-shadow: none; }
  .t-Flying   { background: #A890F0; }
  .t-Psychic  { background: #F85888; }
  .t-Bug      { background: #A8B820; }
  .t-Rock     { background: #B8A038; }
  .t-Ghost    { background: #705898; }
  .t-Dragon   { background: #7038F8; }
  .t-Dark     { background: #705848; }
  .t-Steel    { background: #B8B8D0; color: #333; text-shadow: none; }
  .t-Fairy    { background: #EE99AC; color: #333; text-shadow: none; }

  /* Effectiveness panel */
  .eff-panel { margin: 4px 12px; background: #16213e; border-radius: 12px; padding: 12px; }
  .eff-panel h3 { font-size: 0.85rem; color: #aaa; margin-bottom: 8px; }
  .eff-section { margin-bottom: 12px; }
  .eff-section-title { font-size: 0.75rem; color: #888; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
  .eff-group { margin-bottom: 8px; }
  .eff-group-label { display: inline-block; padding: 1px 7px; border-radius: 10px; font-size: 0.7rem; font-weight: 700; margin-bottom: 4px; }
  .lbl-4x  { background: #8b0000; color: #fff; }
  .lbl-2x  { background: #d4500a; color: #fff; }
  .lbl-05x { background: #1a6b1a; color: #fff; }
  .lbl-025x{ background: #0a4480; color: #fff; }
  .lbl-0x  { background: #444; color: #ccc; }
  .eff-badges { display: flex; flex-wrap: wrap; gap: 4px; }

  /* Quick search tab */
  .type-grid { display: flex; flex-wrap: wrap; gap: 6px; padding: 12px; }
  .type-btn { border: none; border-radius: 8px; padding: 6px 12px; font-size: 0.8rem; font-weight: 700; cursor: pointer; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); transition: transform 0.1s, opacity 0.1s; }
  .type-btn:active { transform: scale(0.95); }
  .type-btn.Electric, .type-btn.Ice, .type-btn.Ground, .type-btn.Steel, .type-btn.Fairy { color: #333; text-shadow: none; }
  .qs-panel { margin: 0 12px; background: #16213e; border-radius: 12px; padding: 12px; }
  .qs-panel h3 { font-size: 0.9rem; margin-bottom: 10px; }

  /* Modal */
  .overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 100; align-items: center; justify-content: center; }
  .overlay.open { display: flex; }
  .modal { background: #16213e; border-radius: 16px; padding: 20px; width: 90%; max-width: 360px; max-height: 90vh; overflow-y: auto; }
  .modal h2 { font-size: 1rem; margin-bottom: 14px; }
  .modal input { width: 100%; background: #1a1a2e; border: 1px solid #3a3a6e; color: #eee; border-radius: 8px; padding: 8px 12px; font-size: 0.9rem; margin-bottom: 4px; }
  .modal input:focus { outline: none; border-color: #6060ff; }
  .autocomplete-wrap { position: relative; margin-bottom: 12px; }
  .autocomplete-list { position: absolute; left: 0; right: 0; background: #1e2a4a; border: 1px solid #3a3a6e; border-radius: 0 0 8px 8px; max-height: 180px; overflow-y: auto; z-index: 200; }
  .ac-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; cursor: pointer; font-size: 0.85rem; }
  .ac-item:hover, .ac-item.focused { background: #2a3a6e; }
  .ac-sprite { width: 32px; height: 32px; object-fit: contain; image-rendering: pixelated; }
  .ac-name { flex: 1; text-transform: capitalize; }
  .ac-types { display: flex; gap: 3px; }
  .ac-loading { padding: 10px; text-align: center; color: #666; font-size: 0.8rem; }
  .autofill-hint { font-size: 0.7rem; color: #6060cc; margin-bottom: 10px; display: none; }
  .autofill-hint.visible { display: block; }
  .modal label { font-size: 0.75rem; color: #aaa; display: block; margin-bottom: 4px; }
  .type-select-grid { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 14px; }
  .type-opt { border: 2px solid transparent; border-radius: 6px; padding: 4px 10px; font-size: 0.72rem; font-weight: 700; cursor: pointer; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
  .type-opt.Electric, .type-opt.Ice, .type-opt.Ground, .type-opt.Steel, .type-opt.Fairy { color: #333; text-shadow: none; }
  .type-opt.selected { border-color: #fff; box-shadow: 0 0 6px rgba(255,255,255,0.4); }
  .type-opt-none { border: 2px solid #3a3a6e; background: #2a2a4e; color: #aaa; border-radius: 6px; padding: 4px 10px; font-size: 0.72rem; cursor: pointer; }
  .type-opt-none.selected { border-color: #fff; color: #fff; }
  .modal-btns { display: flex; gap: 8px; margin-top: 4px; }
  .btn { flex: 1; padding: 10px; border-radius: 8px; border: none; cursor: pointer; font-size: 0.85rem; font-weight: 600; }
  .btn-primary { background: #4040cc; color: #fff; }
  .btn-secondary { background: #2a2a4e; color: #aaa; }
  .btn:active { opacity: 0.8; }

  .hidden { display: none; }
</style>
</head>
<body>
<div class="app">
  <h1>‚öîÔ∏è Pok√©mon Type Tool</h1>
  <div class="lang-toggle">
    <button class="lang-btn active" id="btnDE" onclick="setLang('de')">üá©üá™ Deutsch</button>
    <button class="lang-btn" id="btnEN" onclick="setLang('en')">üá¨üáß English</button>
  </div>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('team')">üèÜ Team</div>
    <div class="tab" onclick="switchTab('search')">üîç Typ-Suche</div>
  </div>

  <!-- Team Tab -->
  <div id="tab-team">
    <div class="team-grid" id="teamGrid"></div>
    <div id="effPanel"></div>
  </div>

  <!-- Quick Search Tab -->
  <div id="tab-search" class="hidden">
    <div class="type-grid" id="typeGrid"></div>
    <div id="qsPanel"></div>
  </div>
</div>

<!-- Modal -->
<div class="overlay" id="overlay" onclick="closeModal(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <h2>Pok√©mon hinzuf√ºgen</h2>
    <label>Name</label>
    <div class="autocomplete-wrap">
      <input type="text" id="pokeName" placeholder="z.B. Charizard..." maxlength="30" autocomplete="off" oninput="onNameInput(this.value)" onkeydown="onNameKey(event)">
      <div class="autocomplete-list" id="acList" style="display:none"></div>
    </div>
    <div class="autofill-hint" id="autofillHint">‚ú® Typen automatisch eingetragen</div>
    <label>Typ 1 *</label>
    <div class="type-select-grid" id="type1Grid"></div>
    <label>Typ 2 (optional)</label>
    <div class="type-select-grid" id="type2Grid"></div>
    <div class="modal-btns">
      <button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button>
      <button class="btn btn-primary" onclick="saveSlot()">Speichern</button>
    </div>
  </div>
</div>

<script>
const TYPES = ['Normal','Fire','Water','Electric','Grass','Ice','Fighting','Poison','Ground','Flying','Psychic','Bug','Rock','Ghost','Dragon','Dark','Steel','Fairy'];

const TYPE_COLORS = {
  Normal:'#A8A878', Fire:'#F08030', Water:'#6890F0', Electric:'#F8D030',
  Grass:'#78C850', Ice:'#98D8D8', Fighting:'#C03028', Poison:'#A040A0',
  Ground:'#E0C068', Flying:'#A890F0', Psychic:'#F85888', Bug:'#A8B820',
  Rock:'#B8A038', Ghost:'#705898', Dragon:'#7038F8', Dark:'#705848',
  Steel:'#B8B8D0', Fairy:'#EE99AC'
};

const LIGHT_TYPES = new Set(['Electric','Ice','Ground','Steel','Fairy']);

const CHART = {
  Normal:   { Rock:0.5, Steel:0.5, Ghost:0 },
  Fire:     { Fire:0.5, Water:0.5, Rock:0.5, Dragon:0.5, Grass:2, Ice:2, Bug:2, Steel:2 },
  Water:    { Water:0.5, Grass:0.5, Dragon:0.5, Fire:2, Ground:2, Rock:2 },
  Electric: { Electric:0.5, Grass:0.5, Dragon:0.5, Ground:0, Water:2, Flying:2 },
  Grass:    { Fire:0.5, Grass:0.5, Poison:0.5, Flying:0.5, Bug:0.5, Dragon:0.5, Steel:0.5, Water:2, Ground:2, Rock:2 },
  Ice:      { Water:0.5, Ice:0.5, Steel:0.5, Grass:2, Ground:2, Flying:2, Dragon:2 },
  Fighting: { Poison:0.5, Flying:0.5, Psychic:0.5, Bug:0.5, Ghost:0, Fairy:0.5, Normal:2, Ice:2, Rock:2, Dark:2, Steel:2 },
  Poison:   { Poison:0.5, Ground:0.5, Rock:0.5, Ghost:0.5, Steel:0, Grass:2, Fairy:2 },
  Ground:   { Grass:0.5, Bug:0.5, Flying:0, Fire:2, Electric:2, Poison:2, Rock:2, Steel:2 },
  Flying:   { Electric:0.5, Rock:0.5, Steel:0.5, Grass:2, Fighting:2, Bug:2 },
  Psychic:  { Psychic:0.5, Steel:0.5, Dark:0, Fighting:2, Poison:2 },
  Bug:      { Fire:0.5, Fighting:0.5, Flying:0.5, Ghost:0.5, Steel:0.5, Fairy:0.5, Grass:2, Psychic:2, Dark:2 },
  Rock:     { Fighting:0.5, Ground:0.5, Steel:0.5, Fire:2, Ice:2, Flying:2, Bug:2 },
  Ghost:    { Normal:0, Dark:0.5, Ghost:2, Psychic:2 },
  Dragon:   { Steel:0.5, Fairy:0, Dragon:2 },
  Dark:     { Fighting:0.5, Dark:0.5, Fairy:0.5, Psychic:2, Ghost:2 },
  Steel:    { Fire:0.5, Water:0.5, Electric:0.5, Steel:0.5, Ice:2, Rock:2, Fairy:2 },
  Fairy:    { Fire:0.5, Poison:0.5, Steel:0.5, Fighting:2, Dragon:2, Dark:2 }
};

// State
let team = JSON.parse(localStorage.getItem('pokeTeam') || '[null,null,null,null,null,null]');
if (!Array.isArray(team) || team.length !== 6) team = Array(6).fill(null);
let editingSlot = -1;
let selectedSlot = -1;
let sel1 = null, sel2 = null;

function saveTeam() { localStorage.setItem('pokeTeam', JSON.stringify(team)); }

function typeBadge(t) {
  return `<span class="badge t-${t}">${t}</span>`;
}

function typeStyle(t) {
  const color = TYPE_COLORS[t];
  const textColor = LIGHT_TYPES.has(t) ? '#333' : '#fff';
  return `background:${color};color:${textColor}`;
}

// Effectiveness calculation
function getDefMultiplier(type1, type2, attacker) {
  let m1 = CHART[attacker]?.[type1] ?? 1;
  let m2 = type2 ? (CHART[attacker]?.[type2] ?? 1) : 1;
  return m1 * m2;
}

function calcDefense(type1, type2) {
  const groups = { 4:[], 2:[], 0.5:[], 0.25:[], 0:[] };
  for (const atk of TYPES) {
    const m = getDefMultiplier(type1, type2, atk);
    if (groups[m] !== undefined) groups[m].push(atk);
  }
  return groups;
}

function calcAttack(type1, type2) {
  const groups = { 2:[], 0.5:[], 0:[] };
  for (const def of TYPES) {
    const m1 = CHART[type1]?.[def] ?? 1;
    const m2 = type2 ? (CHART[type2]?.[def] ?? 1) : 1;
    const best = Math.max(m1, m2);
    // Only show notable results
    if (best === 2) groups[2].push(def);
    else if (best === 0) {
      // Both are immune or 0
      const min = Math.min(m1, m2);
      if (min === 0) groups[0].push(def);
      else if (best < 1) groups[0.5].push(def);
    } else if (best < 1) groups[0.5].push(def);
  }
  // For 0x: only if best possible is 0 (both immune or one immune and other is not super effective)
  // Re-do properly:
  groups[2] = []; groups[0.5] = []; groups[0] = [];
  for (const def of TYPES) {
    const m1 = CHART[type1]?.[def] ?? 1;
    const m2 = type2 ? (CHART[type2]?.[def] ?? 1) : 1;
    const best = Math.max(m1, m2);
    if (best >= 2) groups[2].push(def);
    else if (best === 0) groups[0].push(def);
    else if (best < 1) groups[0.5].push(def);
  }
  return groups;
}

function renderEffGroups(groups, labels) {
  let html = '';
  for (const [mult, label, cls] of labels) {
    const types = groups[mult];
    if (types && types.length > 0) {
      html += `<div class="eff-group">
        <span class="eff-group-label ${cls}">${label}</span>
        <div class="eff-badges">${types.map(t => `<span class="badge t-${t}">${t}</span>`).join('')}</div>
      </div>`;
    }
  }
  return html || '<span style="color:#666;font-size:0.75rem">‚Äì</span>';
}

function renderEffPanel(idx) {
  const p = team[idx];
  if (!p) return '';
  const def = calcDefense(p.type1, p.type2);
  const atk = calcAttack(p.type1, p.type2);

  const defLabels = [
    [4, '4√ó', 'lbl-4x'],
    [2, '2√ó', 'lbl-2x'],
    [0.5, '¬Ω√ó', 'lbl-05x'],
    [0.25, '¬º√ó', 'lbl-025x'],
    [0, '0√ó', 'lbl-0x'],
  ];
  const atkLabels = [
    [2, '2√ó', 'lbl-2x'],
    [0.5, '¬Ω√ó', 'lbl-05x'],
    [0, '0√ó', 'lbl-0x'],
  ];

  return `<div class="eff-panel">
    <h3>${p.name} ‚Äî ${typeBadge(p.type1)}${p.type2 ? ' ' + typeBadge(p.type2) : ''}</h3>
    <div class="eff-section">
      <div class="eff-section-title">üõ°Ô∏è Verteidigung (wird getroffen von‚Ä¶)</div>
      ${renderEffGroups(def, defLabels)}
    </div>
    <div class="eff-section">
      <div class="eff-section-title">üó°Ô∏è Angriff (trifft ‚Ä¶ effektiv)</div>
      ${renderEffGroups(atk, atkLabels)}
    </div>
  </div>`;
}

function renderTeam() {
  const grid = document.getElementById('teamGrid');
  grid.innerHTML = '';
  for (let i = 0; i < 6; i++) {
    const p = team[i];
    const div = document.createElement('div');
    div.className = 'slot' + (!p ? ' empty' : '') + (selectedSlot === i ? ' active' : '');
    if (p) {
      div.innerHTML = `
        <button class="slot-clear" onclick="clearSlot(event,${i})">‚úï</button>
        <div class="slot-name">${p.name}</div>
        <div class="slot-types">${typeBadge(p.type1)}${p.type2 ? typeBadge(p.type2) : ''}</div>`;
      div.onclick = () => selectSlot(i);
    } else {
      div.innerHTML = `<div class="slot-add">Ôºã</div>`;
      div.onclick = () => openModal(i);
    }
    grid.appendChild(div);
  }

  const effPanel = document.getElementById('effPanel');
  if (selectedSlot >= 0 && team[selectedSlot]) {
    effPanel.innerHTML = renderEffPanel(selectedSlot);
  } else {
    effPanel.innerHTML = '';
  }
}

function selectSlot(i) {
  selectedSlot = (selectedSlot === i) ? -1 : i;
  renderTeam();
}

function clearSlot(e, i) {
  e.stopPropagation();
  team[i] = null;
  if (selectedSlot === i) selectedSlot = -1;
  saveTeam();
  renderTeam();
}

// Modal
function openModal(idx) {
  editingSlot = idx;
  sel1 = null; sel2 = null;
  document.getElementById('pokeName').value = '';
  buildTypeSelectors();
  document.getElementById('overlay').classList.add('open');
  setTimeout(() => document.getElementById('pokeName').focus(), 100);
}

function closeModal(e) {
  if (!e || e.target === document.getElementById('overlay')) {
    document.getElementById('overlay').classList.remove('open');
  }
}

function buildTypeSelectors() {
  const g1 = document.getElementById('type1Grid');
  const g2 = document.getElementById('type2Grid');
  g1.innerHTML = '';
  g2.innerHTML = '';

  for (const t of TYPES) {
    const b1 = document.createElement('button');
    b1.className = 'type-opt' + (LIGHT_TYPES.has(t) ? ' ' + t : '');
    b1.textContent = t;
    b1.style.cssText = `background:${TYPE_COLORS[t]};color:${LIGHT_TYPES.has(t)?'#333':'#fff'};border:2px solid transparent`;
    b1.onclick = () => { sel1 = t; updateTypeSelectors(); };
    g1.appendChild(b1);

    const b2 = document.createElement('button');
    b2.className = 'type-opt' + (LIGHT_TYPES.has(t) ? ' ' + t : '');
    b2.textContent = t;
    b2.style.cssText = `background:${TYPE_COLORS[t]};color:${LIGHT_TYPES.has(t)?'#333':'#fff'};border:2px solid transparent`;
    b2.onclick = () => { sel2 = t; updateTypeSelectors(); };
    g2.appendChild(b2);
  }

  // None option for type2
  const none = document.createElement('button');
  none.className = 'type-opt-none selected';
  none.textContent = '‚Äî';
  none.id = 'type2None';
  none.onclick = () => { sel2 = null; updateTypeSelectors(); };
  g2.insertBefore(none, g2.firstChild);

  updateTypeSelectors();
}

function updateTypeSelectors() {
  const g1btns = document.querySelectorAll('#type1Grid .type-opt');
  const g2btns = document.querySelectorAll('#type2Grid .type-opt');
  const g2none = document.getElementById('type2None');

  g1btns.forEach((b, i) => {
    const t = TYPES[i];
    b.style.borderColor = sel1 === t ? '#fff' : 'transparent';
    b.style.boxShadow = sel1 === t ? '0 0 6px rgba(255,255,255,0.5)' : 'none';
  });
  g2btns.forEach((b, i) => {
    const t = TYPES[i];
    b.style.borderColor = sel2 === t ? '#fff' : 'transparent';
    b.style.boxShadow = sel2 === t ? '0 0 6px rgba(255,255,255,0.5)' : 'none';
  });
  if (g2none) {
    g2none.style.borderColor = sel2 === null ? '#fff' : '#3a3a6e';
    g2none.style.color = sel2 === null ? '#fff' : '#aaa';
  }
}

function saveSlot() {
  const name = document.getElementById('pokeName').value.trim() || 'Pok√©mon';
  if (!sel1) { alert('Bitte Typ 1 ausw√§hlen!'); return; }
  team[editingSlot] = { name, type1: sel1, type2: sel2 || null };
  saveTeam();
  selectedSlot = editingSlot;
  document.getElementById('overlay').classList.remove('open');
  renderTeam();
}

// Quick Search Tab
function renderQsTypes() {
  const grid = document.getElementById('typeGrid');
  grid.innerHTML = '';
  for (const t of TYPES) {
    const b = document.createElement('button');
    b.className = 'type-btn';
    b.textContent = t;
    b.style.cssText = `background:${TYPE_COLORS[t]};color:${LIGHT_TYPES.has(t)?'#333':'#fff'}`;
    b.onclick = () => showQs(t, b);
    grid.appendChild(b);
  }
}

let qsActive = null;
function showQs(type, btn) {
  if (qsActive) qsActive.style.outline = 'none';
  btn.style.outline = '2px solid #fff';
  qsActive = btn;

  // Defense for single type
  const defGroups = {};
  for (const atk of TYPES) {
    const m = CHART[atk]?.[type] ?? 1;
    if (!defGroups[m]) defGroups[m] = [];
    defGroups[m].push(atk);
  }
  // Attack for single type
  const atkGroups = {};
  for (const def of TYPES) {
    const m = CHART[type]?.[def] ?? 1;
    if (!atkGroups[m]) atkGroups[m] = [];
    atkGroups[m].push(def);
  }

  const defLabels = [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']];
  const atkLabels = [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']];

  document.getElementById('qsPanel').innerHTML = `
    <div class="qs-panel">
      <h3><span class="badge t-${type}">${type}</span></h3>
      <div class="eff-section">
        <div class="eff-section-title">üõ°Ô∏è Verteidigung (getroffen von‚Ä¶)</div>
        ${renderEffGroups(defGroups, defLabels)}
      </div>
      <div class="eff-section">
        <div class="eff-section-title">üó°Ô∏è Angriff (trifft‚Ä¶ effektiv)</div>
        ${renderEffGroups(atkGroups, atkLabels)}
      </div>
    </div>`;
}

function switchTab(tab) {
  document.querySelectorAll('.tab').forEach((t,i) => t.classList.toggle('active', (i===0&&tab==='team')||(i===1&&tab==='search')));
  document.getElementById('tab-team').classList.toggle('hidden', tab !== 'team');
  document.getElementById('tab-search').classList.toggle('hidden', tab !== 'search');
}

// ‚îÄ‚îÄ‚îÄ Pok√©API Autocomplete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let pokeList = []; // [{name, id}] ‚Äî active language
let pokeEN = [];   // [{name, id}] ‚Äî English (canonical)
let pokeDE = {};   // {id -> deName}
let currentLang = 'de';
let acFocusIdx = -1;

async function loadPokeList() {
  // Load English list
  const EN_KEY = 'pokeList_v1';
  const cachedEN = localStorage.getItem(EN_KEY);
  if (cachedEN) {
    pokeEN = JSON.parse(cachedEN);
  } else {
    try {
      const r = await fetch('https://pokeapi.co/api/v2/pokemon?limit=1025&offset=0');
      const d = await r.json();
      pokeEN = d.results.map((p, i) => ({ name: p.name, id: i + 1 }));
      localStorage.setItem(EN_KEY, JSON.stringify(pokeEN));
    } catch(e) { console.warn('Pok√©API EN not reachable', e); }
  }

  // Load German names via GraphQL
  const DE_KEY = 'pokeDE_v1';
  const cachedDE = localStorage.getItem(DE_KEY);
  if (cachedDE) {
    pokeDE = JSON.parse(cachedDE);
  } else {
    try {
      const r = await fetch('https://beta.pokeapi.co/graphql/v1beta', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: `{ pokemon_v2_pokemonspeciesname(where: {language_id: {_eq: 6}}) { name pokemon_species_id } }` })
      });
      const d = await r.json();
      d.data.pokemon_v2_pokemonspeciesname.forEach(e => { pokeDE[e.pokemon_species_id] = e.name; });
      localStorage.setItem(DE_KEY, JSON.stringify(pokeDE));
    } catch(e) { console.warn('Pok√©API DE not reachable', e); }
  }

  applyLang();
}

function applyLang() {
  if (currentLang === 'de' && Object.keys(pokeDE).length > 0) {
    pokeList = pokeEN.map(p => ({ id: p.id, name: p.name, display: pokeDE[p.id] || capitalize(p.name) }));
  } else {
    pokeList = pokeEN.map(p => ({ id: p.id, name: p.name, display: capitalize(p.name) }));
  }
}

function setLang(lang) {
  currentLang = lang;
  document.getElementById('btnDE').classList.toggle('active', lang === 'de');
  document.getElementById('btnEN').classList.toggle('active', lang === 'en');
  applyLang();
}

function capitalize(name) {
  return name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

function onNameInput(val) {
  const hint = document.getElementById('autofillHint');
  hint.classList.remove('visible');
  if (val.length < 2) { hideAc(); return; }
  const q = val.toLowerCase();
  // Search display name (active lang) and English name
  const matches = pokeList.filter(p =>
    p.display.toLowerCase().startsWith(q) || p.name.startsWith(q)
  ).slice(0, 8);
  if (!matches.length) { hideAc(); return; }
  acFocusIdx = -1;
  const list = document.getElementById('acList');
  list.style.display = 'block';
  list.innerHTML = matches.map((p) => {
    const spriteUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p.id}.png`;
    const sub = currentLang === 'de' ? `<span style="color:#666;font-size:0.7rem">${capitalize(p.name)}</span>` : '';
    return `<div class="ac-item" data-name="${p.name}" data-id="${p.id}" onmousedown="selectPoke('${p.name}',${p.id},'${p.display}')">
      <img class="ac-sprite" src="${spriteUrl}" onerror="this.style.display='none'">
      <span class="ac-name">${p.display} ${sub}</span>
    </div>`;
  }).join('');
}

function onNameKey(e) {
  const list = document.getElementById('acList');
  if (list.style.display === 'none') return;
  const items = list.querySelectorAll('.ac-item');
  if (e.key === 'ArrowDown') { acFocusIdx = Math.min(acFocusIdx + 1, items.length - 1); updateAcFocus(items); e.preventDefault(); }
  else if (e.key === 'ArrowUp') { acFocusIdx = Math.max(acFocusIdx - 1, 0); updateAcFocus(items); e.preventDefault(); }
  else if (e.key === 'Enter' && acFocusIdx >= 0) {
    const item = items[acFocusIdx];
    selectPoke(item.dataset.name, parseInt(item.dataset.id), item.querySelector('.ac-name')?.innerText?.split('\n')[0]);
    e.preventDefault();
  } else if (e.key === 'Escape') { hideAc(); }
}

function updateAcFocus(items) {
  items.forEach((el, i) => el.classList.toggle('focused', i === acFocusIdx));
  if (acFocusIdx >= 0) items[acFocusIdx].scrollIntoView({ block: 'nearest' });
}

function hideAc() {
  document.getElementById('acList').style.display = 'none';
}

async function selectPoke(name, id, display) {
  hideAc();
  document.getElementById('pokeName').value = display || capitalize(name);

  // Fetch types from PokeAPI
  try {
    const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const d = await r.json();
    const types = d.types.sort((a,b) => a.slot - b.slot).map(t => {
      const n = t.type.name;
      return n.charAt(0).toUpperCase() + n.slice(1);
    });
    sel1 = types[0] || null;
    sel2 = types[1] || null;
    updateTypeSelectors();
    const hint = document.getElementById('autofillHint');
    hint.classList.add('visible');
  } catch(e) { console.warn('Could not fetch types', e); }
}

// Init ‚Äî start with DE as default
currentLang = 'de';
loadPokeList();
renderTeam();
renderQsTypes();
</script>
</body>
</html>
