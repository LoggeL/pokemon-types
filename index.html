<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pok√©mon Type Tool</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #0d0d1a; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; min-height: 100vh; }
  .app { max-width: 480px; margin: 0 auto; padding: 0 0 80px; }
  h1 { text-align: center; padding: 16px 16px 8px; font-size: 1.2rem; color: #a0a0c0; letter-spacing: 1px; }
  .top-controls { display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap; }
  .lang-toggle { display: flex; gap: 0; }
  .lang-btn { padding: 4px 14px; border: 1px solid #3a3a6e; background: none; color: #666; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition: all 0.15s; }
  .lang-btn:first-child { border-radius: 6px 0 0 6px; }
  .lang-btn:last-child { border-radius: 0 6px 6px 0; }
  .lang-btn.active { background: #4040cc; color: #fff; border-color: #4040cc; }
  .gen-toggle { display: flex; gap: 0; }
  .gen-label { font-size: 0.72rem; color: #555; line-height: 1; display: flex; align-items: center; padding-right: 4px; }
  .gen-btn { padding: 4px 7px; border: 1px solid #3a3a6e; background: none; color: #555; cursor: pointer; font-size: 0.72rem; font-weight: 700; transition: all 0.15s; border-left: none; }
  .gen-btn:first-of-type { border-left: 1px solid #3a3a6e; border-radius: 6px 0 0 6px; }
  .gen-btn:last-of-type { border-radius: 0 6px 6px 0; }
  .gen-btn.active { background: #2a4a2a; color: #8f8; border-color: #2a6a2a; }
  .move-stats { display: flex; gap: 10px; margin: 4px 0 8px; }
  .move-stat { background: rgba(255,255,255,0.06); border-radius: 6px; padding: 4px 10px; font-size: 0.75rem; color: #aaa; }
  .move-stat span { font-weight: 700; color: #fff; margin-left: 4px; }
  .opponent-strip { background: rgba(0,0,0,0.3); padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
  .opponent-strip-title { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
  .opponent-row { display: flex; align-items: center; gap: 8px; }
  .opponent-input { flex: 1; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #e0e0e0; font-size: 0.8rem; padding: 5px 10px; outline: none; }
  .opponent-clear { background: none; border: none; color: #555; font-size: 1rem; cursor: pointer; padding: 2px 6px; }
  .opponent-info { margin-top: 8px; background: rgba(255,255,255,0.04); border-radius: 8px; padding: 8px 10px; }
  .opponent-matchup { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; align-items: center; }
  .matchup-pill { font-size: 0.75rem; font-weight: 700; padding: 3px 8px; border-radius: 6px; }
  .matchup-super { background: #1a4a1a; color: #8f8; }
  .matchup-not { background: #4a1a1a; color: #f88; }
  .matchup-immune { background: #2a2a2a; color: #888; }

  /* Tabs */
  .tabs { display: flex; border-bottom: 2px solid #2a2a4e; }
  .tab { flex: 1; padding: 10px 4px; text-align: center; cursor: pointer; font-size: 0.82rem; color: #888; transition: all 0.2s; }
  .tab.active { color: #fff; border-bottom: 2px solid #6060ff; margin-bottom: -2px; }

  /* Favorites */
  .fav-grid { display: grid; grid-template-columns: repeat(3,1fr); gap: 8px; padding: 12px; }
  .fav-card { background: #16213e; border-radius: 12px; padding: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.15s, transform 0.1s; position: relative; overflow: hidden; }
  .fav-card:hover { border-color: #3a3a6e; transform: scale(1.03); }
  .fav-card-bg { position: absolute; inset: 0; opacity: 0.15; }
  .fav-card img { width: 64px; height: 64px; object-fit: contain; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); position: relative; z-index: 1; image-rendering: auto; }
  .fav-card-name { font-size: 0.72rem; font-weight: 600; text-align: center; position: relative; z-index: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
  .fav-card-types { display: flex; gap: 3px; justify-content: center; flex-wrap: wrap; position: relative; z-index: 1; }
  .fav-card-del { position: absolute; top: 3px; right: 3px; background: rgba(0,0,0,0.5); border: none; color: #666; font-size: 0.7rem; cursor: pointer; padding: 1px 4px; border-radius: 3px; z-index: 2; line-height: 1.4; }
  .fav-card-del:hover { color: #f55; }
  .fav-empty { text-align: center; padding: 40px 20px; color: #444; font-size: 0.85rem; }
  .fav-add-btn { display: block; margin: 0 12px 12px; padding: 10px; background: #16213e; border: 2px dashed #2a2a4e; border-radius: 12px; color: #555; font-size: 0.85rem; cursor: pointer; text-align: center; width: calc(100% - 24px); }
  .fav-add-btn:hover { border-color: #4040cc; color: #aaa; }
  .modal-favs-title { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
  .modal-fav-chips { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
  .modal-fav-chip { display: flex; align-items: center; gap: 6px; border-radius: 30px; padding: 4px 10px 4px 4px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.15s; background: rgba(255,255,255,0.05); }
  .modal-fav-chip:hover { border-color: rgba(255,255,255,0.3); }
  .modal-fav-chip img { width: 36px; height: 36px; object-fit: contain; image-rendering: pixelated; }
  .modal-fav-chip-name { font-size: 0.78rem; font-weight: 600; }

  /* Team Grid */
  .team-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 12px; }
  .slot {
    background: #111827;
    border-radius: 12px;
    padding: 10px;
    min-height: 80px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: border-color 0.2s;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    overflow: hidden;
  }
  .slot:hover { border-color: #3a3a6e; }
  .slot.active { border-color: #6060ff; }
  .slot.empty { align-items: center; justify-content: center; }
  .slot-add { font-size: 2rem; color: #444; }

  /* Slot artwork & gradient background */
  .slot-bg {
    position: absolute;
    inset: 0;
    opacity: 0.38;
    border-radius: 10px;
  }
  .slot-artwork {
    width: 90px;
    height: 90px;
    object-fit: contain;
    position: relative;
    z-index: 1;
    image-rendering: auto;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
  }
  .slot-placeholder {
    font-size: 2.4rem;
    line-height: 90px;
    height: 90px;
    position: relative;
    z-index: 1;
  }
  .slot-name { font-size: 0.8rem; font-weight: 600; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; position: relative; z-index: 1; }
  .slot-types { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; position: relative; z-index: 1; }
  .slot-clear { position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.5); border: none; color: #aaa; font-size: 0.8rem; cursor: pointer; padding: 2px 5px; border-radius: 4px; z-index: 2; }
  .slot-clear:hover { color: #f00; background: rgba(60,10,10,0.8); }

  /* Type badges */
  .badge { display: inline-block; padding: 2px 8px; border-radius: 6px; font-size: 0.7rem; font-weight: 700; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }

  /* Type colors */
  .t-Normal   { background: #A8A878; }
  .t-Fire     { background: #F08030; }
  .t-Water    { background: #6890F0; }
  .t-Electric { background: #F8D030; color: #333; text-shadow: none; }
  .t-Grass    { background: #78C850; }
  .t-Ice      { background: #98D8D8; color: #333; text-shadow: none; }
  .t-Fighting { background: #C03028; }
  .t-Poison   { background: #A040A0; }
  .t-Ground   { background: #E0C068; color: #333; text-shadow: none; }
  .t-Flying   { background: #A890F0; }
  .t-Psychic  { background: #F85888; }
  .t-Bug      { background: #A8B820; }
  .t-Rock     { background: #B8A038; }
  .t-Ghost    { background: #705898; }
  .t-Dragon   { background: #7038F8; }
  .t-Dark     { background: #705848; }
  .t-Steel    { background: #B8B8D0; color: #333; text-shadow: none; }
  .t-Fairy    { background: #EE99AC; color: #333; text-shadow: none; }

  /* Effectiveness panel */
  .eff-panel { margin: 4px 12px 12px; border-radius: 16px; overflow: hidden; box-shadow: 0 4px 24px rgba(0,0,0,0.5); }
  .eff-panel-header {
    display: flex; align-items: flex-end; gap: 0;
    padding: 16px 16px 12px;
    position: relative; overflow: hidden;
  }
  .eff-header-bg { position: absolute; inset: 0; opacity: 0.25; }
  .eff-header-artwork {
    width: 100px; height: 100px; object-fit: contain;
    filter: drop-shadow(0 4px 12px rgba(0,0,0,0.7));
    position: relative; z-index: 1; flex-shrink: 0;
  }
  .eff-header-placeholder { font-size: 3rem; width: 100px; text-align: center; position: relative; z-index: 1; }
  .eff-header-info { flex: 1; padding-left: 12px; position: relative; z-index: 1; }
  .eff-header-info h3 { font-size: 1.1rem; font-weight: 800; margin-bottom: 6px; text-shadow: 0 1px 4px rgba(0,0,0,0.8); }
  .eff-header-types { display: flex; gap: 5px; flex-wrap: wrap; }

  /* Move grid (2√ó2) */
  .moves-strip { background: rgba(0,0,0,0.3); padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); overflow: visible; }
  .moves-strip-title { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
  .move-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; overflow: visible; position: relative; }
  .move-card { background: rgba(255,255,255,0.04); border-radius: 10px; border: 1px solid rgba(255,255,255,0.06); cursor: pointer; transition: border-color 0.15s; }
  .move-card:hover { border-color: rgba(255,255,255,0.15); }
  .move-card.active-move { border-color: rgba(255,255,255,0.4); }
  .move-card-type-bar { border-radius: 10px 10px 0 0; }
  .move-card-type-bar { height: 3px; }
  .move-card-body { padding: 6px 8px; display: flex; align-items: center; gap: 6px; }
  .move-card-input { flex: 1; background: none; border: none; color: #ddd; font-size: 0.78rem; min-width: 0; padding: 0; }
  .move-card-input:focus { outline: none; color: #fff; }
  .move-card-input::placeholder { color: #444; }
  .move-type-badge-sm { font-size: 0.6rem; font-weight: 700; padding: 2px 6px; border-radius: 4px; white-space: nowrap; cursor: pointer; border: none; flex-shrink: 0; }
  .move-type-badge-empty { background: #2a2a4e; color: #555; }
  .move-picker { background: #0e1628; padding: 8px; display: flex; flex-wrap: wrap; gap: 4px; border-top: 1px solid rgba(255,255,255,0.05); }
  .move-picker-opt { border: 2px solid transparent; border-radius: 5px; padding: 3px 8px; font-size: 0.66rem; font-weight: 700; cursor: pointer; }
  .move-picker-none { border: 2px solid #3a3a6e; background: #2a2a4e; color: #aaa; border-radius: 5px; padding: 3px 8px; font-size: 0.66rem; cursor: pointer; }
  .move-ac-list { position: absolute; left: 0; right: 0; top: 100%; background: #1e2a4a; border: 1px solid #3a3a6e; border-radius: 0 0 8px 8px; max-height: 140px; overflow-y: auto; z-index: 300; }
  .move-ac-item { padding: 5px 10px; cursor: pointer; font-size: 0.78rem; display: flex; align-items: center; gap: 6px; }
  .move-ac-item:hover, .move-ac-item.focused { background: #2a3a6e; }

  /* Effectiveness sections */
  .eff-body { background: #16213e; padding: 12px; }
  .eff-section { margin-bottom: 14px; }
  .eff-section-title { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
  .eff-cards { display: flex; flex-wrap: wrap; gap: 6px; }
  .eff-card {
    border-radius: 10px; overflow: hidden; flex: 0 0 auto;
    min-width: 60px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  .eff-card-header {
    padding: 3px 8px; font-size: 0.7rem; font-weight: 800;
    text-align: center; letter-spacing: 0.5px;
  }
  .eff-card-body { padding: 6px 6px; display: flex; flex-wrap: wrap; gap: 3px; background: rgba(0,0,0,0.25); }
  .ec-4x .eff-card-header  { background: #8b0000; color: #fff; }
  .ec-2x .eff-card-header  { background: #b84000; color: #fff; }
  .ec-05x .eff-card-header { background: #145214; color: #fff; }
  .ec-025x .eff-card-header{ background: #0a3060; color: #fff; }
  .ec-0x .eff-card-header  { background: #333; color: #aaa; }

  /* Move expand */
  .move-expand { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px; margin-top: 6px; }
  .move-expand-title { font-size: 0.72rem; color: #aaa; margin-bottom: 6px; }

  .lbl-4x  { background: #8b0000; color: #fff; }
  .lbl-2x  { background: #d4500a; color: #fff; }
  .lbl-05x { background: #1a6b1a; color: #fff; }
  .lbl-025x{ background: #0a4480; color: #fff; }
  .lbl-0x  { background: #444; color: #ccc; }
  .eff-badges { display: flex; flex-wrap: wrap; gap: 4px; }

  /* Inline move editor */
  .move-row { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; position: relative; }
  .move-input-wrap { flex: 1; position: relative; }
  .move-input-wrap input { width: 100%; background: #0e1628; border: 1px solid #2a2a4e; color: #eee; border-radius: 8px; padding: 6px 10px; font-size: 0.8rem; }
  .move-input-wrap input:focus { outline: none; border-color: #5050cc; }
  .move-ac-list { position: absolute; left: 0; right: 0; top: calc(100% + 2px); background: #1e2a4a; border: 1px solid #3a3a6e; border-radius: 8px; max-height: 140px; overflow-y: auto; z-index: 9999; box-shadow: 0 8px 24px rgba(0,0,0,0.6); }
  .move-ac-item { padding: 5px 10px; cursor: pointer; font-size: 0.78rem; display: flex; align-items: center; gap: 6px; }
  .move-ac-item:hover, .move-ac-item.focused { background: #2a3a6e; }
  .move-type-btn { border: none; border-radius: 6px; padding: 4px 8px; font-size: 0.7rem; font-weight: 700; cursor: pointer; white-space: nowrap; min-width: 56px; text-align: center; }
  .move-type-btn-empty { background: #2a2a4e; color: #666; }
  .move-picker { background: #0e1628; border-radius: 10px; padding: 8px; margin-bottom: 6px; display: flex; flex-wrap: wrap; gap: 4px; }
  .move-picker-opt { border: 2px solid transparent; border-radius: 5px; padding: 3px 8px; font-size: 0.68rem; font-weight: 700; cursor: pointer; }
  .move-picker-none { border: 2px solid #3a3a6e; background: #2a2a4e; color: #aaa; border-radius: 5px; padding: 3px 8px; font-size: 0.68rem; cursor: pointer; }
  .move-expand { background: #0e1628; border-radius: 10px; padding: 10px; margin-bottom: 8px; }
  .move-expand-title { font-size: 0.72rem; color: #aaa; margin-bottom: 6px; }

  /* Quick search tab */
  .type-grid { display: flex; flex-wrap: wrap; gap: 6px; padding: 12px; }
  .type-btn { border: none; border-radius: 8px; padding: 6px 12px; font-size: 0.8rem; font-weight: 700; cursor: pointer; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); transition: transform 0.1s, opacity 0.1s; }
  .type-btn:active { transform: scale(0.95); }
  .type-btn.Electric, .type-btn.Ice, .type-btn.Ground, .type-btn.Steel, .type-btn.Fairy { color: #333; text-shadow: none; }
  .qs-panel { margin: 0 12px; background: #16213e; border-radius: 12px; padding: 12px; }
  .qs-panel h3 { font-size: 0.9rem; margin-bottom: 10px; }

  /* Modal */
  .overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 100; align-items: center; justify-content: center; }
  .overlay.open { display: flex; }
  .modal { background: #16213e; border-radius: 16px; padding: 20px; width: 90%; max-width: 380px; max-height: 92vh; overflow-y: auto; }
  .modal h2 { font-size: 1rem; margin-bottom: 14px; }
  .modal input[type=text] { width: 100%; background: #1a1a2e; border: 1px solid #3a3a6e; color: #eee; border-radius: 8px; padding: 8px 12px; font-size: 0.9rem; margin-bottom: 4px; }
  .modal input[type=text]:focus { outline: none; border-color: #6060ff; }
  .autocomplete-wrap { position: relative; margin-bottom: 12px; }
  .autocomplete-list { position: absolute; left: 0; right: 0; background: #1a2540; border: 1px solid #3a3a6e; border-radius: 0 0 12px 12px; max-height: 280px; overflow-y: auto; z-index: 9999; box-shadow: 0 8px 24px rgba(0,0,0,0.6); }
  .ac-item { display: flex; align-items: center; gap: 12px; padding: 10px 14px; cursor: pointer; font-size: 0.9rem; border-bottom: 1px solid rgba(255,255,255,0.04); }
  .ac-item:last-child { border-bottom: none; }
  .ac-item:hover, .ac-item.focused { background: #2a3a6e; }
  .ac-sprite { width: 52px; height: 52px; object-fit: contain; image-rendering: pixelated; flex-shrink: 0; }
  .ac-name { flex: 1; font-size: 0.9rem; font-weight: 600; }
  .ac-types { display: flex; gap: 3px; }
  .ac-loading { padding: 10px; text-align: center; color: #666; font-size: 0.8rem; }
  .autofill-hint { font-size: 0.7rem; color: #6060cc; margin-bottom: 10px; display: none; }
  .autofill-hint.visible { display: block; }
  .modal label { font-size: 0.75rem; color: #aaa; display: block; margin-bottom: 4px; }
  .type-select-grid { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 14px; }
  .type-opt { border: 2px solid transparent; border-radius: 6px; padding: 4px 10px; font-size: 0.72rem; font-weight: 700; cursor: pointer; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
  .type-opt.Electric, .type-opt.Ice, .type-opt.Ground, .type-opt.Steel, .type-opt.Fairy { color: #333; text-shadow: none; }
  .type-opt.selected { border-color: #fff; box-shadow: 0 0 6px rgba(255,255,255,0.4); }
  .type-opt-none { border: 2px solid #3a3a6e; background: #2a2a4e; color: #aaa; border-radius: 6px; padding: 4px 10px; font-size: 0.72rem; cursor: pointer; }
  .type-opt-none.selected { border-color: #fff; color: #fff; }
  .modal-btns { display: flex; gap: 8px; margin-top: 4px; }
  .btn { flex: 1; padding: 10px; border-radius: 8px; border: none; cursor: pointer; font-size: 0.85rem; font-weight: 600; }
  .btn-primary { background: #4040cc; color: #fff; }
  .btn-secondary { background: #2a2a4e; color: #aaa; }
  .btn:active { opacity: 0.8; }

  /* Moves section in modal */
  .moves-section { margin-bottom: 14px; }
  .moves-section-title { font-size: 0.8rem; color: #aaa; margin-bottom: 10px; font-weight: 600; }
  .move-input-row { background: #1a1a2e; border-radius: 10px; padding: 10px; margin-bottom: 8px; }
  .move-input-row label { font-size: 0.7rem; color: #888; margin-bottom: 5px; display: block; }
  .move-input-row input[type=text] { margin-bottom: 8px; }
  .move-type-mini-grid { display: flex; flex-wrap: wrap; gap: 4px; }
  .move-type-btn {
    border: 2px solid transparent;
    border-radius: 5px;
    padding: 2px 7px;
    font-size: 0.65rem;
    font-weight: 700;
    cursor: pointer;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    transition: border-color 0.1s;
  }
  .move-type-btn.light-type { color: #333; text-shadow: none; }
  .move-type-btn.selected { border-color: #fff; box-shadow: 0 0 5px rgba(255,255,255,0.4); }
  .move-type-none-btn {
    border: 2px solid #3a3a6e;
    background: #2a2a4e;
    color: #aaa;
    border-radius: 5px;
    padding: 2px 7px;
    font-size: 0.65rem;
    cursor: pointer;
  }
  .move-type-none-btn.selected { border-color: #fff; color: #fff; }

  .hidden { display: none; }
</style>
</head>
<body>
<div class="app">
  <h1>‚öîÔ∏è Pok√©mon Type Tool</h1>
  <div class="top-controls">
    <div class="lang-toggle">
      <button class="lang-btn active" id="btnDE" onclick="setLang('de')">üá©üá™ DE</button>
      <button class="lang-btn" id="btnEN" onclick="setLang('en')">üá¨üáß EN</button>
    </div>
    <div style="display:flex;align-items:center;gap:0">
      <span class="gen-label">Gen</span>
      <div class="gen-toggle" id="genToggle"></div>
    </div>
  </div>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('team')" id="tab-btn-team">üèÜ Team</div>
    <div class="tab" onclick="switchTab('favs')" id="tab-btn-favs">‚≠ê Favoriten</div>
    <div class="tab" onclick="switchTab('search')" id="tab-btn-search">üîç Typ-Suche</div>
  </div>

  <!-- Team Tab -->
  <div id="tab-team">
    <div class="team-grid" id="teamGrid"></div>
    <div id="effPanel"></div>
  </div>

  <!-- Favorites Tab -->
  <div id="tab-favs" class="hidden">
    <button class="fav-add-btn" onclick="openFavSearch()">Ôºã Pok√©mon zu Favoriten hinzuf√ºgen</button>
    <div class="fav-grid" id="favGrid"></div>
  </div>

  <!-- Quick Search Tab -->
  <div id="tab-search" class="hidden">
    <div class="type-grid" id="typeGrid"></div>
    <div id="qsPanel"></div>
  </div>
</div>

<!-- Modal -->
<div class="overlay" id="overlay" onclick="closeModal(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <h2>Pok√©mon hinzuf√ºgen</h2>
    <div id="modalFavs"></div>
    <label>Suche</label>
    <div class="autocomplete-wrap">
      <input type="text" id="pokeName" placeholder="z.B. Charizard..." maxlength="30" autocomplete="off" oninput="onNameInput(this.value)" onkeydown="onNameKey(event)">
      <div class="autocomplete-list" id="acList" style="display:none"></div>
    </div>
    <div class="autofill-hint" id="autofillHint">‚ú® Typen automatisch eingetragen</div>
    <p style="font-size:0.75rem;color:#555;margin-bottom:8px">Pok√©mon aus der Liste ausw√§hlen ‚Äî Typen werden automatisch gesetzt.</p>
    <button onclick="toggleTypeOverride()" style="background:none;border:1px solid #2a2a4e;color:#666;border-radius:6px;padding:4px 10px;font-size:0.72rem;cursor:pointer;margin-bottom:10px" id="typeOverrideToggle">‚öôÔ∏è Typ manuell √ºberschreiben (Arceus / Amigento)</button>
    <div id="typeOverridePanel" style="display:none">
      <label>Typ 1</label>
      <div class="type-select-grid" id="type1Grid"></div>
      <label>Typ 2 (optional)</label>
      <div class="type-select-grid" id="type2Grid"></div>
    </div>
    <div class="modal-btns">
      <button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button>
      <button class="btn btn-primary" onclick="saveSlot()">Speichern</button>
    </div>
  </div>
</div>

<script>
const TYPES = ['Normal','Fire','Water','Electric','Grass','Ice','Fighting','Poison','Ground','Flying','Psychic','Bug','Rock','Ghost','Dragon','Dark','Steel','Fairy'];

const TYPE_MIN_GEN = { Dark: 2, Steel: 2, Fairy: 6 }; // all others: Gen 1

const GEN_NAME_TO_NUM = {
  'generation-i':1,'generation-ii':2,'generation-iii':3,'generation-iv':4,
  'generation-v':5,'generation-vi':6,'generation-vii':7,'generation-viii':8,'generation-ix':9
};

function getPokeTypesAtGen(p, gen) {
  if (!p.past_types?.length) return { type1: p.type1, type2: p.type2 };
  const sorted = [...p.past_types]
    .map(pt => ({ ...pt, g: GEN_NAME_TO_NUM[pt.generation?.name] || 9 }))
    .sort((a,b) => a.g - b.g);
  for (const pt of sorted) {
    if (gen <= pt.g) {
      const types = pt.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name.charAt(0).toUpperCase()+t.type.name.slice(1));
      // Filter types that exist in this gen
      const filtered = types.filter(t => (TYPE_MIN_GEN[t]||1) <= gen);
      return { type1: filtered[0] || p.type1, type2: filtered[1] || null };
    }
  }
  return { type1: p.type1, type2: p.type2 };
}

function typesForGen(gen) {
  return TYPES.filter(t => (TYPE_MIN_GEN[t] || 1) <= gen);
}

const TYPE_DE = {
  Normal:'Normal', Fire:'Feuer', Water:'Wasser', Electric:'Elektro',
  Grass:'Pflanze', Ice:'Eis', Fighting:'Kampf', Poison:'Gift',
  Ground:'Boden', Flying:'Flug', Psychic:'Psycho', Bug:'K√§fer',
  Rock:'Gestein', Ghost:'Geist', Dragon:'Drache', Dark:'Unlicht',
  Steel:'Stahl', Fairy:'Fee'
};

const UI_STRINGS = {
  de: {
    tab_team: 'üèÜ Team', tab_favs: '‚≠ê Favoriten', tab_search: 'üîç Typ-Suche',
    defense: 'üõ°Ô∏è Verteidigung ‚Äî getroffen von',
    attack_move: '‚ö° Attacke ‚Äî trifft effektiv',
    moves: '‚öîÔ∏è Attacken',
    add_pokemon: 'Pok√©mon hinzuf√ºgen',
    search_placeholder: 'z.B. Glumanda‚Ä¶',
    move_placeholder: 'Attacke',
    team_full: 'Team ist voll!',
    select_pokemon: 'Bitte ein Pok√©mon aus der Liste ausw√§hlen!',
  },
  en: {
    tab_team: 'üèÜ Team', tab_favs: '‚≠ê Favorites', tab_search: 'üîç Type Search',
    defense: 'üõ°Ô∏è Defense ‚Äî hit by',
    attack_move: '‚ö° Move ‚Äî hits effectively',
    moves: '‚öîÔ∏è Moves',
    add_pokemon: 'Add Pok√©mon',
    search_placeholder: 'e.g. Charmander‚Ä¶',
    move_placeholder: 'Move',
    team_full: 'Team is full!',
    select_pokemon: 'Please select a Pok√©mon from the list!',
  }
};

function t(key) { return (UI_STRINGS[currentLang] || UI_STRINGS.de)[key] || key; }
function typeLabel(type) { return currentLang === 'de' ? (TYPE_DE[type] || type) : type; }

const TYPE_COLORS = {
  Normal:'#A8A878', Fire:'#F08030', Water:'#6890F0', Electric:'#F8D030',
  Grass:'#78C850', Ice:'#98D8D8', Fighting:'#C03028', Poison:'#A040A0',
  Ground:'#E0C068', Flying:'#A890F0', Psychic:'#F85888', Bug:'#A8B820',
  Rock:'#B8A038', Ghost:'#705898', Dragon:'#7038F8', Dark:'#705848',
  Steel:'#B8B8D0', Fairy:'#EE99AC'
};

const LIGHT_TYPES = new Set(['Electric','Ice','Ground','Steel','Fairy']);

const CHART = {
  Normal:   { Rock:0.5, Steel:0.5, Ghost:0 },
  Fire:     { Fire:0.5, Water:0.5, Rock:0.5, Dragon:0.5, Grass:2, Ice:2, Bug:2, Steel:2 },
  Water:    { Water:0.5, Grass:0.5, Dragon:0.5, Fire:2, Ground:2, Rock:2 },
  Electric: { Electric:0.5, Grass:0.5, Dragon:0.5, Ground:0, Water:2, Flying:2 },
  Grass:    { Fire:0.5, Grass:0.5, Poison:0.5, Flying:0.5, Bug:0.5, Dragon:0.5, Steel:0.5, Water:2, Ground:2, Rock:2 },
  Ice:      { Water:0.5, Ice:0.5, Steel:0.5, Grass:2, Ground:2, Flying:2, Dragon:2 },
  Fighting: { Poison:0.5, Flying:0.5, Psychic:0.5, Bug:0.5, Ghost:0, Fairy:0.5, Normal:2, Ice:2, Rock:2, Dark:2, Steel:2 },
  Poison:   { Poison:0.5, Ground:0.5, Rock:0.5, Ghost:0.5, Steel:0, Grass:2, Fairy:2 },
  Ground:   { Grass:0.5, Bug:0.5, Flying:0, Fire:2, Electric:2, Poison:2, Rock:2, Steel:2 },
  Flying:   { Electric:0.5, Rock:0.5, Steel:0.5, Grass:2, Fighting:2, Bug:2 },
  Psychic:  { Psychic:0.5, Steel:0.5, Dark:0, Fighting:2, Poison:2 },
  Bug:      { Fire:0.5, Fighting:0.5, Flying:0.5, Ghost:0.5, Steel:0.5, Fairy:0.5, Grass:2, Psychic:2, Dark:2 },
  Rock:     { Fighting:0.5, Ground:0.5, Steel:0.5, Fire:2, Ice:2, Flying:2, Bug:2 },
  Ghost:    { Normal:0, Dark:0.5, Ghost:2, Psychic:2 },
  Dragon:   { Steel:0.5, Fairy:0, Dragon:2 },
  Dark:     { Fighting:0.5, Dark:0.5, Fairy:0.5, Psychic:2, Ghost:2 },
  Steel:    { Fire:0.5, Water:0.5, Electric:0.5, Steel:0.5, Ice:2, Rock:2, Fairy:2 },
  Fairy:    { Fire:0.5, Poison:0.5, Steel:0.5, Fighting:2, Dragon:2, Dark:2 }
};

// State
let team = JSON.parse(localStorage.getItem('pokeTeam') || '[null,null,null,null,null,null]');
if (!Array.isArray(team) || team.length !== 6) team = Array(6).fill(null);

// Migrate old slots without moves/pokeId
team = team.map(p => p ? { name: p.name, type1: p.type1, type2: p.type2 || null, pokeId: p.pokeId || null, past_types: p.past_types || [], moves: p.moves || [{name:'',type:null},{name:'',type:null},{name:'',type:null},{name:'',type:null}], abilities: p.abilities || [], selectedAbility: p.selectedAbility || null, selectedNature: p.selectedNature || null } : null);

let editingSlot = -1;
let selectedSlot = -1;
let sel1 = null, sel2 = null;
let selectedPokeId = null;
let selectedPastTypes = [];
let opponent = null; // {name, type1, type2, pokeId, past_types, allMoves}
let opponentLevel = 50;
let activeOppMove = null; // {name, type}
let selectedAbilities = [];
let activeMove = null;    // expanded move index in panel
let openPicker = null;    // open type picker index in panel
let moveAcIdx = [-1,-1,-1,-1]; // focused ac item per move

function saveTeam() { localStorage.setItem('pokeTeam', JSON.stringify(team)); }

function typeBadge(type) {
  return `<span class="badge t-${type}">${typeLabel(type)}</span>`;
}

function typeStyle(t) {
  const color = TYPE_COLORS[t];
  const textColor = LIGHT_TYPES.has(t) ? '#333' : '#fff';
  return `background:${color};color:${textColor};text-shadow:${LIGHT_TYPES.has(t)?'none':'0 1px 2px rgba(0,0,0,0.5)'}`;
}

// Effectiveness calculation
function getDefMultiplier(type1, type2, attacker) {
  let m1 = CHART[attacker]?.[type1] ?? 1;
  let m2 = type2 ? (CHART[attacker]?.[type2] ?? 1) : 1;
  return m1 * m2;
}

function calcDefense(type1, type2) {
  const groups = { 4:[], 2:[], 0.5:[], 0.25:[], 0:[] };
  for (const atk of typesForGen(currentGen)) {
    const m = getDefMultiplier(type1, type2, atk);
    if (groups[m] !== undefined) groups[m].push(atk);
  }
  return groups;
}

function calcAttack(type1, type2) {
  const groups = { 2:[], 0.5:[], 0:[] };
  for (const def of typesForGen(currentGen)) {
    const m1 = CHART[type1]?.[def] ?? 1;
    const m2 = type2 ? (CHART[type2]?.[def] ?? 1) : 1;
    const best = Math.max(m1, m2);
    if (best >= 2) groups[2].push(def);
    else if (best === 0) groups[0].push(def);
    else if (best < 1) groups[0.5].push(def);
  }
  return groups;
}

function calcMoveOffense(moveType) {
  // Offensive effectiveness of a single move type
  const groups = { 2:[], 0.5:[], 0:[] };
  for (const def of typesForGen(currentGen)) {
    const m = CHART[moveType]?.[def] ?? 1;
    if (m >= 2) groups[2].push(def);
    else if (m === 0) groups[0].push(def);
    else if (m < 1) groups[0.5].push(def);
  }
  return groups;
}

function getAbilityDisplayName(abilityName) {
  const cached = abilityNameCache[abilityName];
  if (cached) return currentLang === 'de' ? (cached.de || cached.en || abilityName) : (cached.en || abilityName);
  return capitalize(abilityName);
}

async function loadAbilityInfo(abilityName, slotIdx) {
  if (abilityDescCache[abilityName] && abilityNameCache[abilityName]) {
    reRenderPanel(slotIdx);
    return;
  }
  try {
    const r = await fetch(`https://pokeapi.co/api/v2/ability/${abilityName}`);
    const d = await r.json();
    // Names
    const deNameEntry = d.names.find(n => n.language.name === 'de');
    const enNameEntry = d.names.find(n => n.language.name === 'en');
    abilityNameCache[abilityName] = { de: deNameEntry?.name || capitalize(abilityName), en: enNameEntry?.name || capitalize(abilityName) };
    localStorage.setItem('abilityNames_v1', JSON.stringify(abilityNameCache));
    // Descriptions
    const deFlavorEntries = d.flavor_text_entries.filter(e => e.language.name === 'de');
    const enFlavorEntries = d.flavor_text_entries.filter(e => e.language.name === 'en');
    const deDesc = deFlavorEntries.length ? deFlavorEntries[deFlavorEntries.length-1].flavor_text.replace(/\n|\f/g,' ') : null;
    const enDesc = enFlavorEntries.length ? enFlavorEntries[enFlavorEntries.length-1].flavor_text.replace(/\n|\f/g,' ') : null;
    const enEffect = d.effect_entries.find(e => e.language.name === 'en');
    abilityDescCache[abilityName] = { de: deDesc || enEffect?.short_effect || enDesc || '', en: enDesc || enEffect?.short_effect || '' };
    localStorage.setItem('abilityDescs_v1', JSON.stringify(abilityDescCache));
  } catch(e) { console.warn('Ability fetch failed', e); }
  reRenderPanel(slotIdx);
}

function selectAbility(slotIdx, abilityName) {
  if (!team[slotIdx]) return;
  team[slotIdx].selectedAbility = team[slotIdx].selectedAbility === abilityName ? null : abilityName;
  saveTeam();
  if (team[slotIdx].selectedAbility) loadAbilityInfo(abilityName, slotIdx);
  else reRenderPanel(slotIdx);
}

async function fetchAbilitiesIfMissing(idx) {
  const p = team[idx];
  if (!p?.pokeId || p.abilities?.length) return;
  try {
    const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${p.pokeId}`);
    const d = await r.json();
    team[idx].abilities = d.abilities.map(a => ({ name: a.ability.name, isHidden: a.is_hidden }));
    saveTeam();
    if (selectedSlot === idx) document.getElementById('effPanel').innerHTML = renderEffPanel(idx);
  } catch(e) {}
}

function renderAbilitySection(idx, p) {
  if (!p.abilities || !p.abilities.length) {
    fetchAbilitiesIfMissing(idx);
    return '<div style="padding:8px 12px;font-size:0.72rem;color:#555">Lade F√§higkeiten...</div>';
  }
  const title = currentLang === 'de' ? 'üîÆ F√§higkeit' : 'üîÆ Ability';
  const hiddenLabel = currentLang === 'de' ? '(Versteckt)' : '(Hidden)';
  const chips = p.abilities.map(a => {
    const selected = p.selectedAbility === a.name;
    const displayName = getAbilityDisplayName(a.name);
    const bg = a.isHidden ? 'background:#b8860b;color:#fff;' : 'background:rgba(255,255,255,0.08);color:#ccc;';
    const border = selected ? 'border:2px solid #fff;' : 'border:2px solid transparent;';
    const label = a.isHidden ? ` <span style="font-size:0.6rem;opacity:0.7">${hiddenLabel}</span>` : '';
    return `<button onclick="selectAbility(${idx},'${a.name}')" style="${bg}${border}border-radius:20px;padding:4px 12px;font-size:0.75rem;cursor:pointer;font-weight:600">${displayName}${label}</button>`;
  }).join('');
  let descHtml = '';
  if (p.selectedAbility && abilityDescCache[p.selectedAbility]) {
    const desc = abilityDescCache[p.selectedAbility][currentLang] || abilityDescCache[p.selectedAbility].en || '';
    if (desc) descHtml = `<p style="font-size:0.78rem;color:#bbb;margin-top:8px;line-height:1.5">${desc}</p>`;
  }
  return `<div style="background:rgba(0,0,0,0.3);padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.05)">
    <div style="font-size:0.65rem;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">${title}</div>
    <div style="display:flex;flex-wrap:wrap;gap:6px">${chips}</div>
    ${descHtml}
  </div>`;
}

function selectNature(slotIdx, enName) {
  if (!team[slotIdx]) return;
  team[slotIdx].selectedNature = team[slotIdx].selectedNature === enName ? null : enName;
  saveTeam();
  naturePickerOpen = false;
  reRenderPanel(slotIdx);
}

function toggleNaturePicker(slotIdx) {
  naturePickerOpen = !naturePickerOpen;
  reRenderPanel(slotIdx);
}

function renderNatureSection(idx, p) {
  const title = currentLang === 'de' ? 'üåü Wesen' : 'üåü Nature';
  const nat = p.selectedNature ? NATURES.find(n => n.en === p.selectedNature) : null;
  const btnLabel = nat ? (currentLang === 'de' ? nat.de : nat.en) : (currentLang === 'de' ? 'W√§hlen‚Ä¶' : 'Choose‚Ä¶');
  
  let effectText = '';
  if (nat) {
    if (!nat.inc) {
      effectText = 'Neutral';
    } else {
      const incName = currentLang === 'de' ? STAT_DE[nat.inc] : nat.inc;
      const decName = currentLang === 'de' ? STAT_DE[nat.dec] : nat.dec;
      effectText = `<span style="color:#5c5">+10% ${incName}</span> / <span style="color:#c55">-10% ${decName}</span>`;
    }
  }

  let pickerHtml = '';
  if (naturePickerOpen) {
    const chips = NATURES.map(n => {
      const selected = p.selectedNature === n.en;
      const label = currentLang === 'de' ? n.de : n.en;
      let bg = 'background:rgba(255,255,255,0.06);color:#999;';
      if (n.inc) {
        bg = 'background:rgba(255,255,255,0.06);color:#ccc;';
      }
      const border = selected ? 'border:2px solid #fff;' : 'border:2px solid transparent;';
      let sub = '';
      if (n.inc) {
        const incShort = currentLang === 'de' ? STAT_DE[n.inc] : n.inc;
        const decShort = currentLang === 'de' ? STAT_DE[n.dec] : n.dec;
        sub = `<div style="font-size:0.55rem;margin-top:1px"><span style="color:#5c5">+${incShort.substring(0,3)}</span> <span style="color:#c55">-${decShort.substring(0,3)}</span></div>`;
      }
      return `<button onclick="selectNature(${idx},'${n.en}')" style="${bg}${border}border-radius:8px;padding:4px 6px;font-size:0.68rem;cursor:pointer;font-weight:600;text-align:center;min-width:60px">${label}${sub}</button>`;
    }).join('');
    pickerHtml = `<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:8px">${chips}</div>`;
  }

  return `<div style="background:rgba(0,0,0,0.3);padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.05)">
    <div style="font-size:0.65rem;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">${title}</div>
    <button onclick="toggleNaturePicker(${idx})" style="background:rgba(255,255,255,0.08);color:#ccc;border:1px solid rgba(255,255,255,0.15);border-radius:8px;padding:6px 14px;font-size:0.8rem;cursor:pointer;font-weight:600">${btnLabel}</button>
    ${effectText ? `<span style="font-size:0.75rem;margin-left:10px">${effectText}</span>` : ''}
    ${pickerHtml}
  </div>`;
}

function renderEffGroups(groups, labels) {
  let html = '<div class="eff-cards">';
  let any = false;
  for (const [mult, label, cls] of labels) {
    const types = groups[mult];
    if (types && types.length > 0) {
      any = true;
      html += `<div class="eff-card ${cls.replace('lbl-','ec-')}">
        <div class="eff-card-header">${label}</div>
        <div class="eff-card-body">${types.map(t => `<span class="badge t-${t}">${t}</span>`).join('')}</div>
      </div>`;
    }
  }
  html += '</div>';
  return any ? html : '<span style="color:#555;font-size:0.75rem">‚Äì</span>';
}

function getOpponentMovesAtGenLevel() {
  if (!opponent?.allMoves?.length) return [];
  const genVGs = Object.entries(VG_TO_GEN).filter(([,g]) => g === currentGen).map(([vg]) => vg);
  const seen = new Set();
  const result = [];
  for (const mv of opponent.allMoves) {
    if (seen.has(mv.move.name)) continue;
    const detail = mv.version_group_details.find(d =>
      d.move_learn_method.name === 'level-up' &&
      genVGs.includes(d.version_group.name) &&
      d.level_learned_at <= opponentLevel
    );
    if (detail) {
      seen.add(mv.move.name);
      const id = mv.move.url.split('/').filter(Boolean).pop();
      const typeEn = moveTypeCache[id] || null;
      const nameDE = moveDE?.[id] || null;
      const dispName = currentLang === 'de' ? (nameDE || capitalize(mv.move.name)) : capitalize(mv.move.name);
      result.push({ name: dispName, level: detail.level_learned_at, type: typeEn, id });
    }
  }
  return result.sort((a,b) => a.level - b.level);
}

function getMoveMultiplierVsOpponent(moveType) {
  if (!opponent) return null;
  const { type1, type2 } = getPokeTypesAtGen(opponent, currentGen);
  return getDefMultiplier(type1, type2, moveType);
}

function renderOpponentSection(slotIdx) {
  const p = team[slotIdx];
  const moves = p?.moves || [];
  const title = currentLang === 'de' ? '‚öîÔ∏è Gegner' : '‚öîÔ∏è Opponent';
  const placeholder = currentLang === 'de' ? 'Gegnerisches Pok√©mon‚Ä¶' : 'Opponent Pok√©mon‚Ä¶';

  let matchupHtml = '';
  if (opponent) {
    const { type1: ot1, type2: ot2 } = getPokeTypesAtGen(opponent, currentGen);
    const oppArt = opponent.pokeId
      ? `<img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${opponent.pokeId}.png" style="width:28px;height:28px;image-rendering:pixelated;vertical-align:middle;margin-right:6px" onerror="this.style.display='none'">`
      : '';
    const moveMatchups = moves.filter(mv => mv?.name).map(mv => {
      const genStats = mv.moveId ? getMoveStatsAtGen(mv.moveId) : null;
      const effType = genStats?.type || mv.type;
      if (!effType) return null;
      const mult = getMoveMultiplierVsOpponent(effType);
      return { name: mv.name, mult };
    }).filter(Boolean);

    const multLabel = m => m >= 4 ? '4√ó' : m >= 2 ? '2√ó' : m === 0 ? '0√ó' : m <= 0.25 ? '¬º√ó' : m < 1 ? '¬Ω√ó' : '1√ó';
    const multCls = m => m >= 2 ? 'matchup-super' : m === 0 ? 'matchup-immune' : m < 1 ? 'matchup-not' : '';

    matchupHtml = `<div class="opponent-info">
      <div style="font-size:0.78rem;color:#ccc">${oppArt}<strong>${opponent.name}</strong> ${typeBadge(ot1)}${ot2?typeBadge(ot2):''}</div>
      ${moveMatchups.length ? `<div class="opponent-matchup">
        ${moveMatchups.map(m => `<span class="matchup-pill ${multCls(m.mult)}">${m.name}: ${multLabel(m.mult)}</span>`).join('')}
      </div>` : ''}
    </div>`;
  }

  // Opponent moveset
  let oppMovesetHtml = '';
  if (opponent?.allMoves?.length) {
    const lvMoves = getOpponentMovesAtGenLevel();
    const lvLabel = currentLang === 'de' ? 'Attacken bis Lv.' : 'Moves up to Lv.';
    oppMovesetHtml = `<div style="margin-top:8px">
      <div style="font-size:0.65rem;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">${lvLabel}${opponentLevel}</div>
      ${lvMoves.length ? `<div style="display:flex;flex-wrap:wrap;gap:4px">
        ${lvMoves.map(m => {
          const isActive = activeOppMove?.name === m.name;
          return `<span title="Lv.${m.level}" onclick="toggleOppMove(${slotIdx},'${m.name.replace(/'/g,"\\'")}','${m.type||''}','${m.id}')"
            style="font-size:0.72rem;background:${isActive?'rgba(255,255,255,0.15)':'rgba(255,255,255,0.07)'};border-radius:6px;padding:3px 7px;display:flex;align-items:center;gap:4px;cursor:pointer;border:1px solid ${isActive?'rgba(255,255,255,0.3)':'transparent'}">
            ${m.type ? `<span class="badge t-${m.type}" style="font-size:0.6rem;padding:1px 5px">${typeLabel(m.type)}</span>` : ''}
            ${m.name} <span style="color:#555;font-size:0.65rem">Lv.${m.level}</span>
          </span>`;

        }).join('')}
      </div>
      ${activeOppMove?.type ? (() => {
        const stats = activeOppMove.id ? getMoveStatsAtGen(activeOppMove.id) : null;
        const isStatus = stats && stats.power === null;
        let effectHtml;
        if (isStatus) {
          const label = currentLang === 'de' ? 'Status-Attacke ‚Äî kein Schaden' : 'Status move ‚Äî no damage';
          effectHtml = `<span style="color:#888;font-style:italic">${label}</span>`;
        } else {
          const { type1, type2 } = getPokeTypesAtGen(team[slotIdx], currentGen);
          const mult = getDefMultiplier(type1, type2, activeOppMove.type);
          const multStr = mult >= 4 ? '4√ó' : mult >= 2 ? '2√ó' : mult === 0 ? (currentLang==='de'?'0√ó (immun)':'0√ó (immune)') : mult <= 0.25 ? '¬º√ó' : mult < 1 ? '¬Ω√ó' : '1√ó';
          const multColor = mult >= 2 ? '#f88' : mult === 0 ? '#888' : mult < 1 ? '#8f8' : '#aaa';
          effectHtml = `${currentLang==='de'?'trifft':'hits'} <strong>${team[slotIdx]?.name}</strong> ${currentLang==='de'?'f√ºr':'for'} <strong style="color:${multColor};font-size:1rem">${multStr}</strong>`;
        }
        return `<div style="margin-top:8px;background:rgba(0,0,0,0.3);border-radius:8px;padding:8px 10px;font-size:0.8rem">
          <span class="badge t-${activeOppMove.type}">${typeLabel(activeOppMove.type)}</span>
          <strong style="color:#fff;margin:0 6px">${activeOppMove.name}</strong>
          ${effectHtml}
        </div>`;
      })() : ''}` : `<span style="color:#555;font-size:0.75rem">${currentLang==='de'?'Keine Level-Up-Attacken in dieser Gen/Level-Kombi':'No level-up moves for this gen/level'}</span>`}
    </div>`;
  }

  return `<div class="opponent-strip">
    <div class="opponent-strip-title">${title}</div>
    <div class="opponent-row">
      <input class="opponent-input" id="oppInput" type="text" placeholder="${placeholder}"
        value="${opponent?.name || ''}"
        oninput="onOppInput(${slotIdx}, this.value)"
        onkeydown="onOppKey(event, ${slotIdx})"
        onblur="setTimeout(()=>hideOppAc(),200)">
      ${opponent ? `
        <input type="number" min="1" max="100" value="${opponentLevel}" title="Level"
          style="width:54px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:#e0e0e0;font-size:0.8rem;padding:5px 8px;outline:none;text-align:center"
          oninput="opponentLevel=Math.min(100,Math.max(1,parseInt(this.value)||1));reRenderPanel(${slotIdx})">
        <button class="opponent-clear" onclick="clearOpponent(${slotIdx})">‚úï</button>
      ` : ''}
    </div>
    <div class="move-ac-list" id="oppAcList" style="display:none;position:relative;top:0;left:0;width:100%;margin-top:4px;max-height:180px;overflow-y:auto;z-index:999"></div>
    ${matchupHtml}
    ${oppMovesetHtml}
  </div>`;
}

function onOppInput(slotIdx, val) {
  if (val.length < 2) { hideOppAc(); return; }
  const q = val.toLowerCase();
  const results = pokeList.filter(p => p.display.toLowerCase().includes(q)).slice(0, 6);
  const el = document.getElementById('oppAcList');
  if (!el || !results.length) { hideOppAc(); return; }
  el.style.display = 'block';
  el.innerHTML = results.map(p =>
    `<div class="ac-item" onmousedown="selectOpp(${slotIdx},${p.id},'${p.name}','${p.display.replace(/'/g,"\\'")}')">
      <img class="ac-sprite" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p.id}.png" onerror="this.style.display='none'">
      <span>${p.display}</span>
    </div>`
  ).join('');
}

function onOppKey(e, slotIdx) {
  if (e.key === 'Escape') { hideOppAc(); clearOpponent(slotIdx); }
}

function hideOppAc() {
  const el = document.getElementById('oppAcList');
  if (el) el.style.display = 'none';
}

async function selectOpp(slotIdx, id, name, display) {
  hideOppAc();
  opponent = { name: display, pokeId: id, type1: null, type2: null, past_types: [] };
  document.getElementById('oppInput') && (document.getElementById('oppInput').value = display);
  try {
    const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const d = await r.json();
    const types = d.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name.charAt(0).toUpperCase()+t.type.name.slice(1));
    opponent = { name: display, pokeId: id, type1: types[0]||null, type2: types[1]||null, past_types: d.past_types || [], allMoves: d.moves || [] };
  } catch(e) {}
  reRenderPanel(slotIdx);
  prefetchOpponentMoveTypes(slotIdx);
}

function clearOpponent(slotIdx) {
  opponent = null;
  activeOppMove = null;
  reRenderPanel(slotIdx);
}

async function prefetchOpponentMoveTypes(slotIdx) {
  if (!opponent?.allMoves?.length) return;
  const missing = opponent.allMoves
    .map(mv => mv.move.url.split('/').filter(Boolean).pop())
    .filter(id => !moveTypeCache[id]);
  if (!missing.length) return;
  // Fetch in parallel batches of 10
  for (let i = 0; i < missing.length; i += 10) {
    const batch = missing.slice(i, i + 10);
    await Promise.all(batch.map(async id => {
      try {
        const r = await fetch(`https://pokeapi.co/api/v2/move/${id}`);
        const d = await r.json();
        moveTypeCache[id] = d.type.name.charAt(0).toUpperCase() + d.type.name.slice(1);
        if (!moveDescCache[id]) {
          const getDesc = lang => (d.flavor_text_entries||[]).filter(e=>e.language.name===lang).map(e=>e.flavor_text.replace(/\n|\f/g,' ')).pop() || null;
          moveDescCache[id] = { de: getDesc('de'), en: getDesc('en') };
        }
        if (!moveStatCache[id]) {
          moveStatCache[id] = { power: d.power, accuracy: d.accuracy, pp: d.pp, past_values: d.past_values || [] };
        }
      } catch(e) {}
    }));
    localStorage.setItem('moveTypes_v1', JSON.stringify(moveTypeCache));
    localStorage.setItem('moveDescs_v1', JSON.stringify(moveDescCache));
    localStorage.setItem('moveStats_v1', JSON.stringify(moveStatCache));
    reRenderPanel(slotIdx); // update after each batch
  }
}

function toggleOppMove(slotIdx, name, type, id) {
  activeOppMove = (activeOppMove?.name === name) ? null : { name, type: type || null, id: id || null };
  reRenderPanel(slotIdx);
}

function renderEffPanel(idx) {
  const p = team[idx];
  if (!p) return '';
  const { type1, type2 } = getPokeTypesAtGen(p, currentGen);
  const def = calcDefense(type1, type2);
  const atk = calcAttack(type1, type2);
  const defLabels = [[4,'4√ó','lbl-4x'],[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0.25,'¬º√ó','lbl-025x'],[0,'0√ó','lbl-0x']];
  const atkLabels = [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']];

  // Header background gradient
  const col1 = TYPE_COLORS[type1] || '#3a3a6e';
  const col2 = type2 ? TYPE_COLORS[type2] : col1;
  const artUrl = p.pokeId
    ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.pokeId}.png`
    : null;
  const artHtml = artUrl
    ? `<img class="eff-header-artwork" src="${artUrl}" alt="${p.name}" onerror="this.style.display='none'">`
    : `<div class="eff-header-placeholder">‚ö™</div>`;

  // Move grid
  const moves = p.moves || Array(4).fill(null).map(()=>({name:'',type:null}));
  let moveGridHtml = '';
  for (let i = 0; i < 4; i++) {
    const mv = moves[i] || {name:'',type:null};
    const genStats = mv.moveId ? getMoveStatsAtGen(mv.moveId) : null;
    const effectiveType = genStats?.type || mv.type;
    const barColor = effectiveType ? TYPE_COLORS[effectiveType] : 'transparent';
    const typeBtnHtml = effectiveType
      ? `<button class="move-type-badge-sm" style="${typeStyle(effectiveType)}" onmousedown="toggleMoveExpand(${idx},${i})">${typeLabel(effectiveType)}</button>`
      : `<span class="move-type-badge-sm move-type-badge-empty">?</span>`;
    moveGridHtml += `<div style="position:relative">
      <div class="move-card${activeMove===i?' active-move':''}" onclick="toggleMoveExpand(${idx},${i})">
        <div class="move-card-type-bar" style="background:${barColor}"></div>
        <div class="move-card-body">
          <div class="move-input-wrap">
            <input class="move-card-input" type="text" value="${mv.name||''}" placeholder="Attacke ${i+1}‚Ä¶"
              oninput="onMoveInput(${idx},${i},this.value)"
              onkeydown="onMoveKey(event,${idx},${i})"
              onblur="hideMoveAc(${i})"
              onclick="event.stopPropagation()"
              id="moveIn${idx}_${i}">
          </div>
          ${typeBtnHtml}
        </div>
      </div>
      <div class="move-ac-list" id="moveAc${idx}_${i}" style="display:none"></div>

    </div>`;
  }

  return `<div class="eff-panel">
    <div class="eff-panel-header" style="background:linear-gradient(135deg,${col1}33,${col2}44)">
      <div class="eff-header-bg" style="background:linear-gradient(135deg,${col1},${col2})"></div>
      ${artHtml}
      <div class="eff-header-info">
        <h3>${p.name}</h3>
        <div class="eff-header-types">${typeBadge(type1)}${type2?typeBadge(type2):''}</div>
      </div>
    </div>
    ${renderAbilitySection(idx, p)}
    ${renderNatureSection(idx, p)}
    ${renderOpponentSection(idx)}
    <div class="moves-strip">
      <div class="moves-strip-title">${t('moves')}</div>
      <div class="move-grid">${moveGridHtml}</div>
      ${activeMove !== null && moves[activeMove]?.type ? (() => {
        const mv = moves[activeMove];
        const desc = mv.moveId ? (moveDescCache[mv.moveId]?.[currentLang] || moveDescCache[mv.moveId]?.en || '') : '';
        const stats = mv.moveId ? getMoveStatsAtGen(mv.moveId) : null;
        const expandType = stats?.type || mv.type;
        const statsHtml = stats ? `<div class="move-stats">
          ${stats.power != null ? `<div class="move-stat">${currentLang==='de'?'St√§rke':'Power'}<span>${stats.power}</span></div>` : ''}
          ${stats.accuracy != null ? `<div class="move-stat">${currentLang==='de'?'Genauigkeit':'Accuracy'}<span>${stats.accuracy}%</span></div>` : ''}
          ${stats.pp != null ? `<div class="move-stat">PP<span>${stats.pp}</span></div>` : ''}
        </div>` : '';
        return `<div class="move-expand" style="margin-top:8px">
          <div class="move-expand-title">‚ö° <span class="badge t-${expandType}">${typeLabel(expandType)}</span>${mv.name ? ` ‚Äî ${mv.name}` : ''}</div>
          ${statsHtml}
          ${desc ? `<p style="font-size:0.78rem;color:#bbb;margin:0 0 10px;line-height:1.5">${desc}</p>` : ''}
          ${stats?.power && expandType ? renderEffGroups(calcMoveOffense(expandType), [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']]) : ''}
        </div>`;
      })() : ''}
    </div>
    <div class="eff-body">
      <div class="eff-section">
        <div class="eff-section-title">${t('defense')}</div>
        ${renderEffGroups(def, defLabels)}
      </div>
    </div>
  </div>`;
}

function toggleMoveExpand(slotIdx, moveIdx) {
  activeMove = (activeMove === moveIdx) ? null : moveIdx;
  reRenderPanel(slotIdx);
}

function toggleTypeOverride() {
  const panel = document.getElementById('typeOverridePanel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

function reRenderPanel(slotIdx) {
  document.getElementById('effPanel').innerHTML = renderEffPanel(slotIdx);
}

let moveDebounce = null;
function onMoveInput(slotIdx, moveIdx, val) {
  // Save to state (debounced)
  clearTimeout(moveDebounce);
  moveDebounce = setTimeout(() => {
    if (!team[slotIdx]) return;
    if (!team[slotIdx].moves) team[slotIdx].moves = Array(4).fill(null).map(()=>({name:'',type:null}));
    team[slotIdx].moves[moveIdx] = { ...team[slotIdx].moves[moveIdx], name: val };
    saveTeam();
  }, 400);
  // Autocomplete
  if (val.length < 2) { hideMoveAcEl(slotIdx, moveIdx); return; }
  const q = val.toLowerCase();
  const matches = moveList.filter(m => m.display.toLowerCase().startsWith(q) || m.name.startsWith(q)).slice(0, 6);
  const acEl = document.getElementById(`moveAc${slotIdx}_${moveIdx}`);
  if (!acEl) return;
  if (!matches.length) { acEl.style.display = 'none'; return; }
  moveAcIdx[moveIdx] = -1;
  acEl.style.display = 'block';
  acEl.innerHTML = matches.map(m => {
    const typePart = moveTypeCache[m.id] ? `<span class="badge t-${moveTypeCache[m.id]}" style="font-size:0.6rem">${moveTypeCache[m.id]}</span>` : '';
    return `<div class="move-ac-item" data-name="${m.name}" data-id="${m.id}" data-display="${m.display}"
      onmousedown="selectMoveItem(${slotIdx},${moveIdx},'${m.name}',${m.id},'${m.display}')">
      ${m.display} ${m.display!==capitalize(m.name)?`<span style="color:#555;font-size:0.7rem">${capitalize(m.name)}</span>`:''} ${typePart}
    </div>`;
  }).join('');
}

function onMoveKey(e, slotIdx, moveIdx) {
  const acEl = document.getElementById(`moveAc${slotIdx}_${moveIdx}`);
  if (!acEl || acEl.style.display === 'none') return;
  const items = acEl.querySelectorAll('.move-ac-item');
  if (e.key === 'ArrowDown') { moveAcIdx[moveIdx] = Math.min(moveAcIdx[moveIdx]+1, items.length-1); updateMoveAcFocus(items, moveIdx); e.preventDefault(); }
  else if (e.key === 'ArrowUp') { moveAcIdx[moveIdx] = Math.max(moveAcIdx[moveIdx]-1, 0); updateMoveAcFocus(items, moveIdx); e.preventDefault(); }
  else if (e.key === 'Enter' && moveAcIdx[moveIdx] >= 0) {
    const it = items[moveAcIdx[moveIdx]];
    selectMoveItem(slotIdx, moveIdx, it.dataset.name, parseInt(it.dataset.id), it.dataset.display);
    e.preventDefault();
  } else if (e.key === 'Escape') { hideMoveAcEl(slotIdx, moveIdx); }
}

function updateMoveAcFocus(items, moveIdx) {
  items.forEach((el,i) => el.classList.toggle('focused', i === moveAcIdx[moveIdx]));
  if (moveAcIdx[moveIdx] >= 0) items[moveAcIdx[moveIdx]].scrollIntoView({block:'nearest'});
}

function hideMoveAc(moveIdx) {
  // called onblur ‚Äî find and hide by current selectedSlot
  if (selectedSlot >= 0) hideMoveAcEl(selectedSlot, moveIdx);
}
function hideMoveAcEl(slotIdx, moveIdx) {
  const el = document.getElementById(`moveAc${slotIdx}_${moveIdx}`);
  if (el) el.style.display = 'none';
}

async function selectMoveItem(slotIdx, moveIdx, name, id, display) {
  if (!team[slotIdx]) return;
  if (!team[slotIdx].moves) team[slotIdx].moves = Array(4).fill(null).map(()=>({name:'',type:null}));
  // Set name
  const inputEl = document.getElementById(`moveIn${slotIdx}_${moveIdx}`);
  if (inputEl) inputEl.value = display;
  hideMoveAcEl(slotIdx, moveIdx);
  // Fetch type (with cache)
  let moveType = moveTypeCache[id] || null;
  if (!moveType || !moveDescCache[id] || !moveStatCache[id]) {
    try {
      const r = await fetch(`https://pokeapi.co/api/v2/move/${id}`);
      const d = await r.json();
      if (!moveType) {
        moveType = d.type.name.charAt(0).toUpperCase() + d.type.name.slice(1);
        moveTypeCache[id] = moveType;
        localStorage.setItem('moveTypes_v1', JSON.stringify(moveTypeCache));
      }
      const getDesc = (lang) => {
        const entries = (d.flavor_text_entries || []).filter(e => e.language.name === lang);
        return entries.length ? entries[entries.length - 1].flavor_text.replace(/\n|\f/g, ' ') : null;
      };
      moveDescCache[id] = { de: getDesc('de'), en: getDesc('en') };
      localStorage.setItem('moveDescs_v1', JSON.stringify(moveDescCache));
      moveStatCache[id] = { power: d.power, accuracy: d.accuracy, pp: d.pp, past_values: d.past_values || [] };
      localStorage.setItem('moveStats_v1', JSON.stringify(moveStatCache));
    } catch(e) {}
  }
  team[slotIdx].moves[moveIdx] = { name: display, type: moveType, moveId: id };
  saveTeam();
  activeMove = moveType ? moveIdx : null;
  openPicker = null;
  reRenderPanel(slotIdx);
}

function renderTeam() {
  const grid = document.getElementById('teamGrid');
  grid.innerHTML = '';
  for (let i = 0; i < 6; i++) {
    const p = team[i];
    const div = document.createElement('div');
    div.className = 'slot' + (!p ? ' empty' : '') + (selectedSlot === i ? ' active' : '');

    if (p) {
      // Background gradient from type color
      const { type1: gt1, type2: gt2 } = getPokeTypesAtGen(p, currentGen);
      const col1 = TYPE_COLORS[gt1] || '#3a3a6e';
      const col2 = gt2 ? TYPE_COLORS[gt2] : col1;
      div.innerHTML = `
        <div class="slot-bg" style="background:linear-gradient(135deg,${col1},${col2})"></div>
        <button class="slot-clear" onclick="clearSlot(event,${i})">‚úï</button>
        ${p.pokeId
          ? `<img class="slot-artwork" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.pokeId}.png" alt="${p.name}" onerror="this.outerHTML='<div class=slot-placeholder>‚ö™</div>'">`
          : `<div class="slot-placeholder">‚ö™</div>`
        }
        <div class="slot-name">${p.name}</div>
        <div class="slot-types">${typeBadge(gt1)}${gt2 ? typeBadge(gt2) : ''}</div>`;
      div.onclick = (e) => { if (!e.target.classList.contains('slot-clear')) selectSlot(i); };
    } else {
      div.innerHTML = `<div class="slot-add">Ôºã</div>`;
      div.onclick = () => openModal(i);
    }
    grid.appendChild(div);
  }

  const effPanel = document.getElementById('effPanel');
  if (selectedSlot >= 0 && team[selectedSlot]) {
    effPanel.innerHTML = renderEffPanel(selectedSlot);
  } else {
    effPanel.innerHTML = '';
  }
}

function selectSlot(i) {
  if (selectedSlot !== i) { activeMove = null; naturePickerOpen = false; }
  selectedSlot = (selectedSlot === i) ? -1 : i;
  renderTeam();
}

function clearSlot(e, i) {
  e.stopPropagation();
  team[i] = null;
  if (selectedSlot === i) { selectedSlot = -1; activeMove = null; }
  saveTeam();
  renderTeam();
}

// Modal
function openModal(idx) {
  editingSlot = idx;
  sel1 = null; sel2 = null;
  selectedPokeId = null;
  selectedPastTypes = [];
  selectedAbilities = [];
  document.getElementById('pokeName').value = '';
  document.getElementById('autofillHint').classList.remove('visible');
  document.getElementById('typeOverridePanel').style.display = 'none';
  buildTypeSelectors();
  renderModalFavs();
  document.getElementById('overlay').classList.add('open');
  setTimeout(() => document.getElementById('pokeName').focus(), 100);
}

function closeModal(e) {
  if (!e || e.target === document.getElementById('overlay')) {
    document.getElementById('overlay').classList.remove('open');
    hideAc();
  }
}

function buildTypeSelectors() {
  const g1 = document.getElementById('type1Grid');
  const g2 = document.getElementById('type2Grid');
  g1.innerHTML = '';
  g2.innerHTML = '';

  for (const t of TYPES) {
    const b1 = document.createElement('button');
    b1.className = 'type-opt' + (LIGHT_TYPES.has(t) ? ' ' + t : '');
    b1.textContent = t;
    b1.style.cssText = `background:${TYPE_COLORS[t]};color:${LIGHT_TYPES.has(t)?'#333':'#fff'};border:2px solid transparent`;
    b1.onclick = () => { sel1 = t; updateTypeSelectors(); };
    g1.appendChild(b1);

    const b2 = document.createElement('button');
    b2.className = 'type-opt' + (LIGHT_TYPES.has(t) ? ' ' + t : '');
    b2.textContent = t;
    b2.style.cssText = `background:${TYPE_COLORS[t]};color:${LIGHT_TYPES.has(t)?'#333':'#fff'};border:2px solid transparent`;
    b2.onclick = () => { sel2 = t; updateTypeSelectors(); };
    g2.appendChild(b2);
  }

  const none = document.createElement('button');
  none.className = 'type-opt-none selected';
  none.textContent = '‚Äî';
  none.id = 'type2None';
  none.onclick = () => { sel2 = null; updateTypeSelectors(); };
  g2.insertBefore(none, g2.firstChild);

  updateTypeSelectors();
}

function updateTypeSelectors() {
  const g1btns = document.querySelectorAll('#type1Grid .type-opt');
  const g2btns = document.querySelectorAll('#type2Grid .type-opt');
  const g2none = document.getElementById('type2None');

  g1btns.forEach((b, i) => {
    const t = TYPES[i];
    b.style.borderColor = sel1 === t ? '#fff' : 'transparent';
    b.style.boxShadow = sel1 === t ? '0 0 6px rgba(255,255,255,0.5)' : 'none';
  });
  g2btns.forEach((b, i) => {
    const t = TYPES[i];
    b.style.borderColor = sel2 === t ? '#fff' : 'transparent';
    b.style.boxShadow = sel2 === t ? '0 0 6px rgba(255,255,255,0.5)' : 'none';
  });
  if (g2none) {
    g2none.style.borderColor = sel2 === null ? '#fff' : '#3a3a6e';
    g2none.style.color = sel2 === null ? '#fff' : '#aaa';
  }
}


function saveSlot() {
  const name = document.getElementById('pokeName').value.trim() || 'Pok√©mon';
  if (!sel1) { alert('Bitte ein Pok√©mon aus der Liste ausw√§hlen!'); return; }
  const existing = team[editingSlot];
  const existingMoves = existing?.moves || Array(4).fill(null).map(()=>({name:'',type:null}));
  team[editingSlot] = {
    name,
    type1: sel1,
    type2: sel2 || null,
    pokeId: selectedPokeId || null,
    past_types: selectedPastTypes || [],
    moves: existingMoves,
    abilities: selectedAbilities.length ? selectedAbilities : (existing?.abilities || []),
    selectedAbility: existing?.selectedAbility || null,
    selectedNature: existing?.selectedNature || null
  };
  saveTeam();
  selectedSlot = editingSlot;
  activeMove = null;
  openPicker = null;
  document.getElementById('overlay').classList.remove('open');
  renderTeam();
}

// Quick Search Tab
function renderQsTypes() {
  const grid = document.getElementById('typeGrid');
  grid.innerHTML = '';
  for (const type of typesForGen(currentGen)) {
    const b = document.createElement('button');
    b.className = 'type-btn';
    b.textContent = typeLabel(type);
    b.style.cssText = `background:${TYPE_COLORS[type]};color:${LIGHT_TYPES.has(type)?'#333':'#fff'}`;
    b.onclick = () => showQs(type, b);
    grid.appendChild(b);
  }
}

let qsActive = null;
function showQs(type, btn) {
  if (qsActive) qsActive.style.outline = 'none';
  btn.style.outline = '2px solid #fff';
  qsActive = btn;

  const defGroups = {};
  for (const atk of typesForGen(currentGen)) {
    const m = CHART[atk]?.[type] ?? 1;
    if (!defGroups[m]) defGroups[m] = [];
    defGroups[m].push(atk);
  }
  const atkGroups = {};
  for (const def of typesForGen(currentGen)) {
    const m = CHART[type]?.[def] ?? 1;
    if (!atkGroups[m]) atkGroups[m] = [];
    atkGroups[m].push(def);
  }

  const defLabels = [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']];
  const atkLabels = [[2,'2√ó','lbl-2x'],[0.5,'¬Ω√ó','lbl-05x'],[0,'0√ó','lbl-0x']];

  document.getElementById('qsPanel').innerHTML = `
    <div class="qs-panel">
      <h3>${typeBadge(type)}</h3>
      <div class="eff-section">
        <div class="eff-section-title">${t('defense')}</div>
        ${renderEffGroups(defGroups, defLabels)}
      </div>
      <div class="eff-section">
        <div class="eff-section-title">${currentLang==='de'?'üó°Ô∏è Angriff ‚Äî trifft effektiv':'üó°Ô∏è Attack ‚Äî hits effectively'}</div>
        ${renderEffGroups(atkGroups, atkLabels)}
      </div>
    </div>`;
}

function switchTab(tab) {
  const tabs = ['team','favs','search'];
  document.querySelectorAll('.tab').forEach((t,i) => t.classList.toggle('active', tabs[i] === tab));
  document.getElementById('tab-team').classList.toggle('hidden', tab !== 'team');
  document.getElementById('tab-favs').classList.toggle('hidden', tab !== 'favs');
  document.getElementById('tab-search').classList.toggle('hidden', tab !== 'search');
  if (tab === 'favs') renderFavs();
}

// ‚îÄ‚îÄ‚îÄ Pok√©API Autocomplete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let pokeList = [];
let pokeEN = [];
let pokeDE = {};
let currentLang = 'de';
let acFocusIdx = -1;

async function loadPokeList() {
  const EN_KEY = 'pokeList_v1';
  const cachedEN = localStorage.getItem(EN_KEY);
  if (cachedEN) {
    pokeEN = JSON.parse(cachedEN);
  } else {
    try {
      const r = await fetch('https://pokeapi.co/api/v2/pokemon?limit=1025&offset=0');
      const d = await r.json();
      pokeEN = d.results.map((p, i) => ({ name: p.name, id: i + 1 }));
      localStorage.setItem(EN_KEY, JSON.stringify(pokeEN));
    } catch(e) { console.warn('Pok√©API EN not reachable', e); }
  }

  const DE_KEY = 'pokeDE_v1';
  const cachedDE = localStorage.getItem(DE_KEY);
  if (cachedDE) {
    pokeDE = JSON.parse(cachedDE);
  } else {
    try {
      const r = await fetch('https://beta.pokeapi.co/graphql/v1beta', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: `{ pokemon_v2_pokemonspeciesname(where: {language_id: {_eq: 6}}) { name pokemon_species_id } }` })
      });
      const d = await r.json();
      d.data.pokemon_v2_pokemonspeciesname.forEach(e => { pokeDE[e.pokemon_species_id] = e.name; });
      localStorage.setItem(DE_KEY, JSON.stringify(pokeDE));
    } catch(e) { console.warn('Pok√©API DE not reachable', e); }
  }

  applyLang();
}

function applyLang() {
  if (currentLang === 'de' && Object.keys(pokeDE).length > 0) {
    pokeList = pokeEN.map(p => ({ id: p.id, name: p.name, display: pokeDE[p.id] || capitalize(p.name) }));
  } else {
    pokeList = pokeEN.map(p => ({ id: p.id, name: p.name, display: capitalize(p.name) }));
  }
}

function setLang(lang) {
  currentLang = lang;
  document.getElementById('btnDE').classList.toggle('active', lang === 'de');
  document.getElementById('btnEN').classList.toggle('active', lang === 'en');
  applyLang();
  buildMoveList();
  // Update tab labels
  document.getElementById('tab-btn-team').textContent = t('tab_team');
  document.getElementById('tab-btn-favs').textContent = t('tab_favs');
  document.getElementById('tab-btn-search').textContent = t('tab_search');
  // Update Pok√©mon names in team
  team.forEach((p, i) => {
    if (!p) return;
    if (p.pokeId) {
      const found = pokeList.find(pk => pk.id === p.pokeId);
      if (found) team[i].name = found.display;
    }
    // Update move names
    (p.moves || []).forEach((mv, j) => {
      if (!mv?.name) return;
      // Try to resolve moveId if missing
      if (!mv.moveId) {
        const q = mv.name.toLowerCase();
        const byEN = _moveEN.find(m => capitalize(m.name).toLowerCase() === q);
        const byDE = Object.entries(moveDE).find(([,n]) => n.toLowerCase() === q);
        if (byEN) team[i].moves[j].moveId = byEN.id;
        else if (byDE) team[i].moves[j].moveId = parseInt(byDE[0]);
      }
      if (team[i].moves[j].moveId) {
        const found = moveList.find(m => m.id === team[i].moves[j].moveId);
        if (found) team[i].moves[j].name = found.display;
      }
    });
  });
  saveTeam();
  // Update favorite names
  favorites.forEach((f, i) => {
    const found = pokeList.find(pk => pk.id === f.id);
    if (found) favorites[i].display = found.display;
  });
  saveFavs();
  renderTeam();
  renderFavs();
  if (qsActive) { qsActive.style.outline = 'none'; qsActive = null; }
  document.getElementById('qsPanel').innerHTML = '';
  renderQsTypes();
}

function capitalize(name) {
  return name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

function onNameInput(val) {
  const hint = document.getElementById('autofillHint');
  hint.classList.remove('visible');
  if (val.length < 2) { hideAc(); return; }
  const q = val.toLowerCase();
  const matches = pokeList.filter(p =>
    p.display.toLowerCase().startsWith(q) || p.name.startsWith(q)
  ).slice(0, 8);
  if (!matches.length) { hideAc(); return; }
  acFocusIdx = -1;
  const list = document.getElementById('acList');
  list.style.display = 'block';
  list.innerHTML = matches.map((p) => {
    const spriteUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p.id}.png`;
    const sub = currentLang === 'de' ? `<span style="color:#555;font-size:0.7rem">${capitalize(p.name)}</span>` : '';
    const isFav = favorites.some(f => f.id === p.id);
    return `<div class="ac-item" data-name="${p.name}" data-id="${p.id}" onmousedown="selectPoke('${p.name}',${p.id},'${p.display}')">
      <img class="ac-sprite" src="${spriteUrl}" onerror="this.style.display='none'">
      <span class="ac-name">${p.display} ${sub}</span>
      <button style="background:none;border:none;font-size:1.1rem;cursor:pointer;padding:2px 4px;opacity:${isFav?1:0.3}" onmousedown="event.stopPropagation();toggleFavFromAc(${p.id},'${p.name}','${p.display}')" title="Zu Favoriten">${isFav?'‚≠ê':'‚òÜ'}</button>
    </div>`;
  }).join('');
}

function onNameKey(e) {
  const list = document.getElementById('acList');
  if (list.style.display === 'none') return;
  const items = list.querySelectorAll('.ac-item');
  if (e.key === 'ArrowDown') { acFocusIdx = Math.min(acFocusIdx + 1, items.length - 1); updateAcFocus(items); e.preventDefault(); }
  else if (e.key === 'ArrowUp') { acFocusIdx = Math.max(acFocusIdx - 1, 0); updateAcFocus(items); e.preventDefault(); }
  else if (e.key === 'Enter' && acFocusIdx >= 0) {
    const item = items[acFocusIdx];
    selectPoke(item.dataset.name, parseInt(item.dataset.id), item.querySelector('.ac-name')?.innerText?.split('\n')[0]);
    e.preventDefault();
  } else if (e.key === 'Escape') { hideAc(); }
}

function updateAcFocus(items) {
  items.forEach((el, i) => el.classList.toggle('focused', i === acFocusIdx));
  if (acFocusIdx >= 0) items[acFocusIdx].scrollIntoView({ block: 'nearest' });
}

function hideAc() {
  const el = document.getElementById('acList');
  if (el) el.style.display = 'none';
}

async function selectPoke(name, id, display) {
  hideAc();
  selectedPokeId = id;
  document.getElementById('pokeName').value = display || capitalize(name);

  try {
    const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const d = await r.json();
    const types = d.types.sort((a,b) => a.slot - b.slot).map(t => {
      const n = t.type.name;
      return n.charAt(0).toUpperCase() + n.slice(1);
    });
    sel1 = types[0] || null;
    sel2 = types[1] || null;
    selectedPastTypes = d.past_types || [];
    selectedAbilities = d.abilities.map(a => ({ name: a.ability.name, isHidden: a.is_hidden }));
    updateTypeSelectors();
    const hint = document.getElementById('autofillHint');
    hint.classList.add('visible');
  } catch(e) { console.warn('Could not fetch types', e); }
}

// ‚îÄ‚îÄ‚îÄ Favorites ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let favorites = JSON.parse(localStorage.getItem('pokeFavs') || '[]');
function saveFavs() { localStorage.setItem('pokeFavs', JSON.stringify(favorites)); }

function toggleFavFromAc(id, name, display) {
  const idx = favorites.findIndex(f => f.id === id);
  if (idx >= 0) {
    favorites.splice(idx, 1);
  } else {
    // Fetch types then add
    addFav(id, name, display);
  }
  saveFavs();
  // Re-trigger autocomplete display refresh
  const input = document.getElementById('pokeName');
  if (input) onNameInput(input.value);
}

async function addFav(id, name, display) {
  if (favorites.some(f => f.id === id)) return;
  let type1 = null, type2 = null;
  try {
    const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const d = await r.json();
    const types = d.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name.charAt(0).toUpperCase()+t.type.name.slice(1));
    type1 = types[0]||null; type2 = types[1]||null;
    past_types = d.past_types || [];
  } catch(e) {}
  let past_types = [];
  favorites.push({ id, name, display, type1, type2, past_types });
  saveFavs();
  const input = document.getElementById('pokeName');
  if (input && input.value.length >= 2) onNameInput(input.value);
  renderFavs();
}

function renderModalFavs() {
  const el = document.getElementById('modalFavs');
  if (!el) return;
  if (!favorites.length) { el.innerHTML = ''; return; }
  el.innerHTML = `<div class="modal-favs-title">‚≠ê Favoriten</div>
    <div class="modal-fav-chips">
      ${favorites.map(f => {
        const spriteUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${f.id}.png`;
        return `<div class="modal-fav-chip" onclick="selectFavInModal(${f.id},'${f.name}','${f.display}')">
          <img src="${spriteUrl}" onerror="this.style.opacity=0.3">
          <span class="modal-fav-chip-name">${f.display}</span>
        </div>`;
      }).join('')}
    </div>`;
}

async function selectFavInModal(id, name, display) {
  selectedPokeId = id;
  document.getElementById('pokeName').value = display;
  hideAc();
  // Use cached types if fav has them
  const fav = favorites.find(f => f.id === id);
  if (fav && fav.type1) {
    sel1 = fav.type1; sel2 = fav.type2 || null;
    selectedPastTypes = fav.past_types || [];
    updateTypeSelectors();
    document.getElementById('autofillHint').classList.add('visible');
  } else {
    try {
      const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
      const d = await r.json();
      const types = d.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name.charAt(0).toUpperCase()+t.type.name.slice(1));
      sel1 = types[0]||null; sel2 = types[1]||null;
      selectedPastTypes = d.past_types || [];
      updateTypeSelectors();
      document.getElementById('autofillHint').classList.add('visible');
    } catch(e) {}
  }
}

function renderFavs() {
  const grid = document.getElementById('favGrid');
  if (!grid) return;
  if (!favorites.length) {
    grid.innerHTML = '<div class="fav-empty">Noch keine Favoriten.<br>Pok√©mon √ºber die Suche hinzuf√ºgen ‚òÜ</div>';
    return;
  }
  grid.innerHTML = favorites.map((f,i) => {
    const artUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${f.id}.png`;
    const col1 = f.type1 ? TYPE_COLORS[f.type1] : '#3a3a6e';
    const col2 = f.type2 ? TYPE_COLORS[f.type2] : col1;
    return `<div class="fav-card" onclick="addFavToTeam(${i})">
      <div class="fav-card-bg" style="background:linear-gradient(135deg,${col1},${col2})"></div>
      <button class="fav-card-del" onmousedown="event.stopPropagation();removeFav(${i})">‚úï</button>
      <img src="${artUrl}" onerror="this.style.opacity=0.3">
      <div class="fav-card-name">${f.display}</div>
      <div class="fav-card-types">
        ${f.type1?typeBadge(f.type1):''}
        ${f.type2?typeBadge(f.type2):''}
      </div>
    </div>`;
  }).join('');
}

function removeFav(i) {
  favorites.splice(i, 1);
  saveFavs();
  renderFavs();
}

function addFavToTeam(favIdx) {
  const f = favorites[favIdx];
  // Find first empty team slot
  const emptySlot = team.findIndex(s => s === null);
  if (emptySlot < 0) { alert('Team ist voll!'); return; }
  team[emptySlot] = {
    name: f.display,
    type1: f.type1,
    type2: f.type2,
    pokeId: f.id,
    past_types: f.past_types || [],
    moves: Array(4).fill(null).map(()=>({name:'',type:null})),
    abilities: [],
    selectedAbility: null,
    selectedNature: null
  };
  saveTeam();
  switchTab('team');
  selectedSlot = emptySlot;
  renderTeam();
}

function openFavSearch() {
  // Open modal in "fav add" mode ‚Äî no slot needed
  editingSlot = -1;
  sel1 = null; sel2 = null;
  selectedPokeId = null;
  selectedAbilities = [];
  document.getElementById('pokeName').value = '';
  document.getElementById('autofillHint').classList.remove('visible');
  document.getElementById('typeOverridePanel').style.display = 'none';
  buildTypeSelectors();
  // Override save button to add to favs
  document.querySelector('#overlay .btn-primary').textContent = 'Zu Favoriten';
  document.querySelector('#overlay .btn-primary').onclick = saveFavSlot;
  document.getElementById('overlay').classList.add('open');
  setTimeout(() => document.getElementById('pokeName').focus(), 100);
}

function saveFavSlot() {
  if (!selectedPokeId || !sel1) { alert('Bitte ein Pok√©mon aus der Liste ausw√§hlen!'); return; }
  const name = document.getElementById('pokeName').value.trim() || 'Pok√©mon';
  addFav(selectedPokeId, pokeEN.find(p=>p.id===selectedPokeId)?.name||name, name);
  document.getElementById('overlay').classList.remove('open');
  // Restore save button
  document.querySelector('#overlay .btn-primary').textContent = 'Speichern';
  document.querySelector('#overlay .btn-primary').onclick = saveSlot;
  renderFavs();
}

// ‚îÄ‚îÄ‚îÄ Move Autocomplete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let moveList = [];
let moveDE = {};
let moveTypeCache = JSON.parse(localStorage.getItem('moveTypes_v1') || '{}');
let moveDescCache = JSON.parse(localStorage.getItem('moveDescs_v1') || '{}');
let moveStatCache = JSON.parse(localStorage.getItem('moveStats_v1') || '{}'); // {id: {power,accuracy,pp,past_values}}
let abilityDescCache = JSON.parse(localStorage.getItem('abilityDescs_v1') || '{}');
let abilityNameCache = JSON.parse(localStorage.getItem('abilityNames_v1') || '{}');
let currentGen = parseInt(localStorage.getItem('currentGen') || '9');

const NATURES = [
  {en:'Hardy',  de:'Robust',    inc:null,     dec:null},
  {en:'Lonely', de:'Solo',      inc:'Attack', dec:'Defense'},
  {en:'Brave',  de:'K√ºhn',      inc:'Attack', dec:'Speed'},
  {en:'Adamant',de:'Hart',      inc:'Attack', dec:'Sp. Atk'},
  {en:'Naughty',de:'Frech',     inc:'Attack', dec:'Sp. Def'},
  {en:'Bold',   de:'K√ºhn',      inc:'Defense',dec:'Attack'},
  {en:'Docile', de:'Sanft',     inc:null,     dec:null},
  {en:'Relaxed',de:'Locker',    inc:'Defense',dec:'Speed'},
  {en:'Impish', de:'Pfiffig',   inc:'Defense',dec:'Sp. Atk'},
  {en:'Lax',    de:'Lasch',     inc:'Defense',dec:'Sp. Def'},
  {en:'Timid',  de:'Scheu',     inc:'Speed',  dec:'Attack'},
  {en:'Hasty',  de:'Hastig',    inc:'Speed',  dec:'Defense'},
  {en:'Serious',de:'Ernst',     inc:null,     dec:null},
  {en:'Jolly',  de:'Froh',      inc:'Speed',  dec:'Sp. Atk'},
  {en:'Naive',  de:'Naiv',      inc:'Speed',  dec:'Sp. Def'},
  {en:'Modest', de:'M√§√üig',     inc:'Sp. Atk',dec:'Attack'},
  {en:'Mild',   de:'Mild',      inc:'Sp. Atk',dec:'Defense'},
  {en:'Quiet',  de:'Still',     inc:'Sp. Atk',dec:'Speed'},
  {en:'Bashful',de:'Sch√ºchtern',inc:null,     dec:null},
  {en:'Rash',   de:'Hitzig',    inc:'Sp. Atk',dec:'Sp. Def'},
  {en:'Calm',   de:'Sanft',     inc:'Sp. Def',dec:'Attack'},
  {en:'Gentle', de:'Zart',      inc:'Sp. Def',dec:'Defense'},
  {en:'Sassy',  de:'Frech',     inc:'Sp. Def',dec:'Speed'},
  {en:'Careful',de:'Sorgf√§ltig',inc:'Sp. Def',dec:'Sp. Atk'},
  {en:'Quirky', de:'Kauzig',    inc:null,     dec:null},
];
const STAT_DE = { 'Attack':'Angriff','Defense':'Verteidigung','Speed':'Initiative','Sp. Atk':'Sp. Angriff','Sp. Def':'Sp. Verteidigung' };
let naturePickerOpen = false;

const VG_TO_GEN = {
  'red-blue':1,'yellow':1,'gold-silver':2,'crystal':2,
  'ruby-sapphire':3,'firered-leafgreen':3,'emerald':3,
  'diamond-pearl':4,'platinum':4,'heartgold-soulsilver':4,
  'black-white':5,'black-2-white-2':5,
  'x-y':6,'omega-ruby-alpha-sapphire':6,
  'sun-moon':7,'ultra-sun-ultra-moon':7,
  'sword-shield':8,'brilliant-diamond-shining-pearl':8,'legends-arceus':8,
  'scarlet-violet':9
};

function getMoveStatsAtGen(id) {
  const d = moveStatCache[id];
  if (!d) return null;
  let power = d.power, accuracy = d.accuracy, pp = d.pp;
  let type = moveTypeCache[id] || null;
  const past = (d.past_values || [])
    .map(pv => ({ ...pv, g: VG_TO_GEN[pv.version_group?.name] || 9 }))
    .sort((a,b) => a.g - b.g);
  for (const pv of past) {
    if (currentGen <= pv.g) {
      if (pv.power !== undefined && pv.power !== null) power = pv.power;
      if (pv.accuracy !== undefined && pv.accuracy !== null) accuracy = pv.accuracy;
      if (pv.pp !== undefined && pv.pp !== null) pp = pv.pp;
      if (pv.type?.name) type = pv.type.name.charAt(0).toUpperCase() + pv.type.name.slice(1);
      break;
    }
  }
  return { power, accuracy, pp, type };
}

function buildGenToggle() {
  const el = document.getElementById('genToggle');
  if (!el) return;
  el.innerHTML = [1,2,3,4,5,6,7,8,9].map(g =>
    `<button class="gen-btn${currentGen===g?' active':''}" onclick="setGen(${g})">${g}</button>`
  ).join('');
}

function setGen(g) {
  currentGen = g;
  localStorage.setItem('currentGen', g);
  buildGenToggle();
  renderTeam();
  renderQsTypes();
  if (qsActive) { qsActive.style.outline = 'none'; qsActive = null; }
  document.getElementById('qsPanel').innerHTML = '';
}
let _moveEN = [];

async function loadMoveList() {
  const EN_KEY = 'moveList_v1';
  const cachedEN = localStorage.getItem(EN_KEY);
  if (cachedEN) {
    _moveEN = JSON.parse(cachedEN);
  } else {
    try {
      const r = await fetch('https://pokeapi.co/api/v2/move?limit=920&offset=0');
      const d = await r.json();
      _moveEN = d.results.map((m,i) => ({ name: m.name, id: i+1 }));
      localStorage.setItem(EN_KEY, JSON.stringify(_moveEN));
    } catch(e) { console.warn('Move list fetch failed', e); }
  }
  const DE_KEY = 'moveDE_v1';
  const cachedDE = localStorage.getItem(DE_KEY);
  if (cachedDE) {
    moveDE = JSON.parse(cachedDE);
  } else {
    try {
      const r = await fetch('https://beta.pokeapi.co/graphql/v1beta', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: `{ pokemon_v2_movename(where: {language_id: {_eq: 6}}) { name move_id } }` })
      });
      const d = await r.json();
      d.data.pokemon_v2_movename.forEach(e => { moveDE[e.move_id] = e.name; });
      localStorage.setItem(DE_KEY, JSON.stringify(moveDE));
    } catch(e) { console.warn('Move DE fetch failed', e); }
  }
  buildMoveList();
}

function buildMoveList() {
  if (currentLang === 'de' && Object.keys(moveDE).length > 0) {
    moveList = _moveEN.map(m => ({ id: m.id, name: m.name, display: moveDE[m.id] || capitalize(m.name) }));
  } else {
    moveList = _moveEN.map(m => ({ id: m.id, name: m.name, display: capitalize(m.name) }));
  }
}

// Init
currentLang = 'de';
buildGenToggle();
loadPokeList();
loadMoveList();
renderTeam();
renderQsTypes();
</script>
</body>
</html>
